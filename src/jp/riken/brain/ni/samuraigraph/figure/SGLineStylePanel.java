package jp.riken.brain.ni.samuraigraph.figure;

import java.awt.Color;
import java.awt.Component;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import javax.swing.BorderFactory;
import javax.swing.DefaultCellEditor;
import javax.swing.JComboBox;
import javax.swing.JScrollBar;
import javax.swing.JTable;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.MouseInputListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.text.BadLocationException;
import javax.swing.text.Document;

import jp.riken.brain.ni.samuraigraph.base.SGColorDialog;
import jp.riken.brain.ni.samuraigraph.base.SGColorMap;
import jp.riken.brain.ni.samuraigraph.base.SGColorSelectionButton;
import jp.riken.brain.ni.samuraigraph.base.SGComboBox;
import jp.riken.brain.ni.samuraigraph.base.SGDialog;
import jp.riken.brain.ni.samuraigraph.base.SGIConstants;
import jp.riken.brain.ni.samuraigraph.base.SGProperties;
import jp.riken.brain.ni.samuraigraph.base.SGSpinner;
import jp.riken.brain.ni.samuraigraph.base.SGTable;
import jp.riken.brain.ni.samuraigraph.base.SGUtility;
import jp.riken.brain.ni.samuraigraph.base.SGUtilityText;

/**
 * A panel to set the line style.
 *
 */
public class SGLineStylePanel extends javax.swing.JPanel implements SGIConstants, 
		ActionListener, ItemListener, MouseInputListener, MouseWheelListener {

	private static final long serialVersionUID = 643669519397055582L;
	
	/** Creates new form SGLineStylePanel */
    public SGLineStylePanel(SGDialog dg, SGColorDialog colorDialog) {
    	super();
        initComponents();
        this.mDialog = dg;
        this.mColorDialog = colorDialog;
        this.initProperty();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mScrollPanePanel = new javax.swing.JPanel();
        mScrollPane = new javax.swing.JScrollPane();
        mTable = this.createTableInstance();
        mSubPanel = new javax.swing.JPanel();
        mGradientColorPanel = new javax.swing.JPanel();
        mColor2Label = new javax.swing.JLabel();
        mColor1Label = new javax.swing.JLabel();
        mColor2Button = new jp.riken.brain.ni.samuraigraph.base.SGColorSelectionButton();
        mColor1Button = new jp.riken.brain.ni.samuraigraph.base.SGColorSelectionButton();
        mStylePanel = new javax.swing.JPanel();
        mColorMapTypeLabel = new javax.swing.JLabel();
        mColorMapTypeComboBox = new jp.riken.brain.ni.samuraigraph.base.SGComboBox();
        mColorMapRenderParentPanel = new javax.swing.JPanel();
        mReversedOrderCheckBox = new jp.riken.brain.ni.samuraigraph.base.SGCheckBox();
        mAssignColorsButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();

        setLayout(new java.awt.GridBagLayout());

        mScrollPanePanel.setLayout(new java.awt.BorderLayout());

        mScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        mScrollPane.setFont(new java.awt.Font("Dialog", 0, 12));
        mScrollPane.setPreferredSize(new java.awt.Dimension(452, 150));

        mTable.setFont(new java.awt.Font("Dialog", 0, 12));
        mTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        mTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        mScrollPane.setViewportView(mTable);

        mScrollPanePanel.add(mScrollPane, java.awt.BorderLayout.CENTER);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 0, 2);
        add(mScrollPanePanel, gridBagConstraints);

        mSubPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Color Assignation", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 0, 12))); // NOI18N
        mSubPanel.setLayout(new java.awt.GridBagLayout());

        mGradientColorPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Colors In Gradation", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 0, 12))); // NOI18N
        mGradientColorPanel.setLayout(new java.awt.GridBagLayout());

        mColor2Label.setFont(new java.awt.Font("Dialog", 0, 12));
        mColor2Label.setText("Color2");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 20, 2, 5);
        mGradientColorPanel.add(mColor2Label, gridBagConstraints);

        mColor1Label.setFont(new java.awt.Font("Dialog", 0, 12));
        mColor1Label.setText("Color1");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 20, 2, 5);
        mGradientColorPanel.add(mColor1Label, gridBagConstraints);

        mColor2Button.setFont(new java.awt.Font("Dialog", 0, 11));
        mColor2Button.setMinimumSize(new java.awt.Dimension(65, 20));
        mColor2Button.setPreferredSize(new java.awt.Dimension(65, 20));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 2, 10);
        mGradientColorPanel.add(mColor2Button, gridBagConstraints);

        mColor1Button.setFont(new java.awt.Font("Dialog", 0, 11));
        mColor1Button.setMinimumSize(new java.awt.Dimension(65, 20));
        mColor1Button.setPreferredSize(new java.awt.Dimension(65, 20));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 2, 10);
        mGradientColorPanel.add(mColor1Button, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
        mSubPanel.add(mGradientColorPanel, gridBagConstraints);

        mStylePanel.setLayout(new java.awt.GridBagLayout());

        mColorMapTypeLabel.setFont(new java.awt.Font("Dialog", 0, 12));
        mColorMapTypeLabel.setText("Style");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
        mStylePanel.add(mColorMapTypeLabel, gridBagConstraints);

        mColorMapTypeComboBox.setFont(new java.awt.Font("Dialog", 0, 12));
        mColorMapTypeComboBox.setMinimumSize(new java.awt.Dimension(140, 22));
        mColorMapTypeComboBox.setPreferredSize(new java.awt.Dimension(140, 22));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(2, 5, 2, 2);
        mStylePanel.add(mColorMapTypeComboBox, gridBagConstraints);

        mColorMapRenderParentPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        mColorMapRenderParentPanel.setPreferredSize(new java.awt.Dimension(200, 20));
        mColorMapRenderParentPanel.setLayout(new javax.swing.BoxLayout(mColorMapRenderParentPanel, javax.swing.BoxLayout.LINE_AXIS));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
        mStylePanel.add(mColorMapRenderParentPanel, gridBagConstraints);

        mReversedOrderCheckBox.setText("Reversed Order");
        mReversedOrderCheckBox.setFont(new java.awt.Font("Dialog", 0, 12));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 8, 0, 0);
        mStylePanel.add(mReversedOrderCheckBox, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(2, 4, 2, 2);
        mSubPanel.add(mStylePanel, gridBagConstraints);

        mAssignColorsButton.setText("Assign Colors");
        mAssignColorsButton.setFont(new java.awt.Font("Dialog", 1, 12));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 4);
        mSubPanel.add(mAssignColorsButton, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 0, 2);
        add(mSubPanel, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private jp.riken.brain.ni.samuraigraph.base.SGButton mAssignColorsButton;
    private jp.riken.brain.ni.samuraigraph.base.SGColorSelectionButton mColor1Button;
    private javax.swing.JLabel mColor1Label;
    private jp.riken.brain.ni.samuraigraph.base.SGColorSelectionButton mColor2Button;
    private javax.swing.JLabel mColor2Label;
    private javax.swing.JPanel mColorMapRenderParentPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGComboBox mColorMapTypeComboBox;
    private javax.swing.JLabel mColorMapTypeLabel;
    private javax.swing.JPanel mGradientColorPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGCheckBox mReversedOrderCheckBox;
    private javax.swing.JScrollPane mScrollPane;
    private javax.swing.JPanel mScrollPanePanel;
    private javax.swing.JPanel mStylePanel;
    private javax.swing.JPanel mSubPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGTable mTable;
    // End of variables declaration//GEN-END:variables

    /**
     * Name of the column for the sequential number.
     */
    public static final String COLUMN_NAME_NUMBER = "No.";

    /**
     * Name of the column for the name.
     */
    public static final String COLUMN_NAME_NAME = "Name";

    /**
     * Name of the column for the line color.
     */
    public static final String COLUMN_NAME_LINE_COLOR = "Color";

    /**
     * Name of the column for the line width.
     */
    public static final String COLUMN_NAME_LINE_WIDTH = "Width";

    /**
     * Name of the column for the line type.
     */
    public static final String COLUMN_NAME_LINE_TYPE = "Type";
    
	/**
	 * The array of column names.
	 */
	public static final String[] COLUMN_NAME_ARRAY = { COLUMN_NAME_NUMBER,
			COLUMN_NAME_NAME, COLUMN_NAME_LINE_COLOR, COLUMN_NAME_LINE_WIDTH,
			COLUMN_NAME_LINE_TYPE };

	// The array of column width.
	private static final int[] PREFERRED_COLUMN_WIDTH_ARRAY_SXY = { 20, 60, 50, 50, 120 };

    // The parent dialog.
	private SGDialog mDialog = null;

    /**
     * Color map manager.
     */
    private SGColorMapManager mColorMapManager = new SGLineStyleColorMapManager();

    /**
     * The color map.
     */
	private SGColorMap mColorMap = null;
	
	/**
	 * A panel to render the color map.
	 */
	private SGColorMapRendererPanel mColorMapRendererPanel = null;

    /**
     * The table model.
     */
    protected LineStyleTableModel mTableModel = null;

    private SGComboBox mLineTypeRendererComboBox = null;

    private SGComboBox mLineTypeEditorComboBox = null;
    
    private LineWidthCellRenderer mLineWidthRendererSpinner = null;
    
    private LineWidthCellEditor mLineWidthEditorSpinner = null;
    
    private LineColorCellRenderer mLineColorRenderer = null;

    // The color selection dialog.
    private SGColorDialog mColorDialog = null;

    // A dummy color selection button.
	private SGColorSelectionButton mColorSelectionButton = new SGColorSelectionButton();
	
	// row index that the color selection button is clicked
	private int mColorSelectedRowIndex = -1;
	
    private boolean mLineColorAutoAssigned = false;

	private void initProperty() {
		
        // initializes the table
        this.mTableModel = new LineStyleTableModel();
        this.mTableModel.setColumnIdentifiers(COLUMN_NAME_ARRAY);
        this.mTable.setModel(this.mTableModel);
        this.updateTable();

    	// setup the scroll bar
        JScrollBar vertBar = this.mScrollPane.getVerticalScrollBar();
        vertBar.setUnitIncrement(SGIConstants.SCROLL_BAR_UNIT_INCREMENT);
        vertBar.setBlockIncrement(SGIConstants.SCROLL_BAR_BLOCK_INCREMENT);

        // initializes the color map and the components for line colors
        for (String name : SGLineStyleColorMapManager.DEFAULT_COLOR_MAP_NAMES) {
            this.mColorMapTypeComboBox.addItem(name);
        }
        this.setEnabledColorSelectionComponents(false);
        
        // adds this panel as action listeners
        this.mColor1Button.addActionListener(this);
        this.mColor2Button.addActionListener(this);
        this.mAssignColorsButton.addActionListener(this);
        this.mReversedOrderCheckBox.addActionListener(this);
        this.mColorMapTypeComboBox.addItemListener(this);
        this.mTable.addMouseListener(this);
        this.mTable.addMouseMotionListener(this);

        // add the table as a mouse wheel listener
        this.mTable.addMouseWheelListener(this);

        // creates the color map renderer panel
        this.mColorMapRendererPanel = new SGColorMapRendererPanel(new SGLineStyleColorMapManager());
        this.mColorMapRenderParentPanel.add(this.mColorMapRendererPanel);

        // setup the combo box
        this.mLineTypeEditorComboBox = this.createComboBoxInstance();
        this.mLineTypeRendererComboBox = this.createComboBoxInstance();
        this.mLineTypeEditorComboBox.setMaximumRowCount(12);
        this.mLineTypeRendererComboBox.setMaximumRowCount(12);
        
        final int colIndexLineType = this.getColumnIndex(COLUMN_NAME_LINE_TYPE);
        TableColumn lineTypeCol = this.mTable.getColumnModel().getColumn(
                colIndexLineType);
        lineTypeCol.setCellEditor(new LineTypeCellEditor(this.mLineTypeEditorComboBox));
        lineTypeCol.setCellRenderer(new LineTypeCellRenderer(this.mLineTypeRendererComboBox));
        
        final int colIndexLineWidth = this.getColumnIndex(COLUMN_NAME_LINE_WIDTH);
        TableColumn lineWidthCol = this.mTable.getColumnModel().getColumn(
                colIndexLineWidth);
        this.mLineWidthEditorSpinner = new LineWidthCellEditor();
        lineWidthCol.setCellEditor(this.mLineWidthEditorSpinner);
        this.mLineWidthRendererSpinner = new LineWidthCellRenderer();
        lineWidthCol.setCellRenderer(this.mLineWidthRendererSpinner);
        
        final int colIndexLineColor = this.getColumnIndex(COLUMN_NAME_LINE_COLOR);
        TableColumn lineColorCol = this.mTable.getColumnModel().getColumn(
        		colIndexLineColor);
        this.mLineColorRenderer = new LineColorCellRenderer();
        lineColorCol.setCellRenderer(this.mLineColorRenderer);
	}

    /**
     * Creates and returns a table object.
     * 
     * @return a table object
     */
    protected SGTable createTableInstance() {
    	return new SGTable(){
			private static final long serialVersionUID = 3516262871678750712L;
			public String getToolTipText(MouseEvent e){
		    	final int colIndexLineColor = getColumnIndex(COLUMN_NAME_LINE_COLOR);
				final int rowIndex = rowAtPoint(e.getPoint());
				final int colIndex = columnAtPoint(e.getPoint());
            	if (colIndex == colIndexLineColor) {
    				Object obj = getModel().getValueAt(rowIndex, colIndex);
            		Color cl = (Color) obj;
            		return SGUtilityText.getSimpleColorString(cl);
            	} else {
					return super.getToolTipText(e);
            	}
            }
        };
    }

    /**
     * Update the table.
     */
    public void updateTable() {
    	if (this.mTableModel != null) {
            this.setPreferredColumnWidth();
    	}
    }

    /**
     * Scroll the vertical scroll bar.
     */
    public void mouseWheelMoved(MouseWheelEvent e) {
        final int amount = e.getScrollAmount() * e.getWheelRotation();
        JScrollBar vertBar = this.mScrollPane.getVerticalScrollBar();
        final int value = vertBar.getValue() + amount * 6;
        vertBar.setValue(value);
    }

    private SGComboBox createComboBoxInstance() {
    	SGComboBox cb = new SGComboBox();
        cb.setBorder(BorderFactory.createEmptyBorder());
        return cb;
    }

	public void setEnabledColorSelectionComponents(final boolean b) {
		this.mColor1Label.setEnabled(b);
		this.mColor1Button.setEnabled(b);
		this.mColor2Label.setEnabled(b);
		this.mColor2Button.setEnabled(b);
	}

    public void actionPerformed(ActionEvent e) {
    	Object source = e.getSource();
        if (source.equals(this.mAssignColorsButton)) {
        	final int num = this.mTable.getRowCount();
        	final int colIndexLineColor = this.getColumnIndex(COLUMN_NAME_LINE_COLOR);
            final List<SGLineStyle> lineStyleList = SGUtilityForFigureElement.createLineStyleList(
            		this.mColorMap, num);
            for (int ii = 0; ii < num; ii++) {
            	SGLineStyle style = lineStyleList.get(ii);
            	this.mTable.setValueAt(style.getColor(), ii, colIndexLineColor);
            }
            this.mLineColorAutoAssigned = true;
        } else if (source.equals(this.mColor1Button) || source.equals(this.mColor2Button)) {
            this.mColorSelectedRowIndex = -1;
            this.mLineColorRenderer.setFocused(false);
            this.repaint();
        } else if (source.equals(this.mReversedOrderCheckBox)) {
        	Boolean selected = this.mReversedOrderCheckBox.getSelected();
        	if (selected != null) {
        		this.mColorMapRendererPanel.setReversedOrder(selected);
        		this.mColorMapManager.setReversedOrder(this.getSelectedColorMapName(), selected);
                this.repaint();
        	}
        }
	}

    /**
     * Returns the list of line style.
     * 
     * @return the list of line style
     */
    public List<SGLineStyle> getLineStyleList() {
    	final int colIndexNumber = this.getColumnIndex(COLUMN_NAME_NUMBER);
    	final int colIndexLineColor = this.getColumnIndex(COLUMN_NAME_LINE_COLOR);
    	final int colIndexLineWidth = this.getColumnIndex(COLUMN_NAME_LINE_WIDTH);
    	final int colIndexLineType = this.getColumnIndex(COLUMN_NAME_LINE_TYPE);
    	TreeMap<Integer, SGLineStyle> lineStyleMap = new TreeMap<Integer, SGLineStyle>();
    	final int rowNum = this.mTable.getRowCount();
    	for (int ii = 0; ii < rowNum; ii++) {
        	Integer num = (Integer) this.mTable.getValueAt(ii, colIndexNumber);
        	Color cl = (Color) this.mTable.getValueAt(ii, colIndexLineColor);
        	Number lw = (Number) this.mTable.getValueAt(ii, colIndexLineWidth);
        	String typeStr = (String) this.mTable.getValueAt(ii, colIndexLineType);
        	Integer type = SGDrawingElementLine.getLineTypeFromName(typeStr);
        	SGLineStyle lineStyle = new SGLineStyle(type, cl, lw.floatValue());
        	lineStyleMap.put(num, lineStyle);
    	}
    	List<SGLineStyle> lineStyleList = new ArrayList<SGLineStyle>();
    	Iterator<SGLineStyle> itr = lineStyleMap.values().iterator();
    	while (itr.hasNext()) {
    		lineStyleList.add(itr.next());
    	}
    	return lineStyleList;
    }

    /**
     * Adds a line style with the name.
     * 
     * @param name
     *           the name
     * @param lineStyle
     *           the line style
     */
    public void addLineStyle(String name, SGLineStyle lineStyle) {
    	final int index = this.mTableModel.getRowCount();
    	
    	// adds a record
        this.mTableModel.addLineStyle(index, lineStyle);
        
        // sets the name
    	final int colIndexName = this.getColumnIndex(COLUMN_NAME_NAME);
		this.mTable.setValueAt(name, index, colIndexName);
    }

    /**
     * Returns the column index of table.
     *
     * @param identifier
     * @return If the column with given identifier exists, returns the index.
     */
    public int getColumnIndex(final String identifier) {
        return this.mTable.getColumnModel().getColumnIndex(identifier);
    }

    /**
     * Returns a list of color selection buttons.
     *
     * @return a list of color selection buttons
     */
    public List<SGColorSelectionButton> getColorSelectionButtonsList() {
    	List<SGColorSelectionButton> list = new ArrayList<SGColorSelectionButton>();
        list.add(this.mColor1Button);
        list.add(this.mColor2Button);
        list.add(this.mColorSelectionButton);
    	return list;
    }
    
    /**
     * Sets selected color map.
     * 
     * @param name
     *           the name of color map
     */
	public void setSelectedColorMapName(String name) {
		this.mColorMapTypeComboBox.setSelectedItem(name);
    	SGColorMap map = this.mColorMapManager.getColorMap(name);
    	this.mColorMap = map;
    	this.mColorMapRendererPanel.setColorMapName(name);
    	this.updateColorMapComponents(name);
	}

    public boolean setColorMapProperties(Map<String, SGProperties> colorMapProperties) {
    	if (!this.mColorMapManager.setColorMapProperties(colorMapProperties)) {
    		return false;
    	}
    	String name = this.mColorMapManager.getColorMapName(this.mColorMap);
    	this.updateColorMapComponents(name);
    	return true;
    }

	@Override
	public void itemStateChanged(ItemEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mColorMapTypeComboBox)) {
			Object obj = this.mColorMapTypeComboBox.getSelectedItem();
			if (obj != null) {
				String name = obj.toString();
				this.updateColorMapComponents(name);
			}
		}
	}
	
	private void updateColorMapComponents(String name) {
		if (this.mColorMapManager != null) {
			SGColorMap colorMap = this.mColorMapManager.getColorMap(name);
			boolean enabled = true;
			if (name.equals(SGLineStyleColorMapManager.COLOR_MAP_NAME_HUE_GRADATION)) {
				enabled = false;
				this.mColor1Button.setColor(null);
				this.mColor2Button.setColor(null);
			} else if (name.equals(SGLineStyleColorMapManager.COLOR_MAP_NAME_COLOR_GRAY_SCALE)) {
				enabled = true;
				Color[] colors = colorMap.getColors();
				this.mColor1Button.setColor(colors[0]);
				this.mColor2Button.setColor(colors[1]);
			}
			this.setEnabledColorSelectionComponents(enabled);
			this.mColorMap = colorMap;
			
			// sets to the check box
	    	this.setReversedOrder(colorMap.isReversedOrder());

			// sets to the renderer panel
			this.mColorMapRendererPanel.setColorMapName(name);
			this.updateColorMapRenderPanel();
			this.repaint();
		}
	}

	public String getSelectedColorMapName() {
		return this.mColorMapTypeComboBox.getSelectedItem().toString();
	}
	
	private void updateColorMapRenderPanel() {
//		this.mColorMapRendererPanel.setColorMapProperties(this.mColorMap.getProperties());
		this.mColorMapRendererPanel.setColors(this.mColorMap.getColors());
		this.mColorMapRendererPanel.setReversedOrder(this.mColorMap.isReversedOrder());
	}

    protected void buttonColorAssigned(SGColorSelectionButton b) {
		if (this.mColor1Button.equals(b) || this.mColor2Button.equals(b)) {
        	// updates the colors
			Color[] colors = { this.mColor1Button.getColor(), this.mColor2Button.getColor() };
        	this.mColorMap.setColors(colors);
        	
        	// sets to the renderer panel
			this.updateColorMapRenderPanel();
        	this.repaint();
		} else if (this.mColorSelectionButton.equals(b)) {
			// from the table
			if (this.mColorSelectedRowIndex != -1) {
				final int colIndex = this.getColumnIndex(COLUMN_NAME_LINE_COLOR);
				Color color = this.mColorDialog.getSelectedColor();
				this.mTable.setValueAt(color, this.mColorSelectedRowIndex, colIndex);
	        	this.repaint();
			}
		}
    }

    public SGProperties getColorMapProperties(final String name) {
    	SGColorMap colorMap = this.mColorMapManager.getColorMap(name);
    	return colorMap.getProperties();
    }
    
    public Map<String, SGProperties> getColorMapProperties() {
    	return this.mColorMapManager.getColorMapProperties();
    }
    
    /**
     * Sets preferred size of columns.
     * 
     */
    private void setPreferredColumnWidth() {
        for (int ii = 0; ii < COLUMN_NAME_ARRAY.length; ii++) {
            TableColumn cl = this.mTable.getColumn(COLUMN_NAME_ARRAY[ii]);
            cl.setPreferredWidth(PREFERRED_COLUMN_WIDTH_ARRAY_SXY[ii]);
        }
    }

    class LineWidthCellRenderer extends SGSpinner implements TableCellRenderer {

		private static final long serialVersionUID = -6160575841774434580L;

		public LineWidthCellRenderer() {
    		super();
	        this.initProperties(
	        		SGUtility.getLineWidthSpinnerNumberModel(),
	                LINE_WIDTH_UNIT, LINE_WIDTH_FRAC_DIGIT_MIN, LINE_WIDTH_FRAC_DIGIT_MAX);
    	}
    	
		@Override
		public Component getTableCellRendererComponent(JTable table,
				Object value, boolean isSelected, boolean hasFocus, int row,
				int column) {
			this.setValue(value);
			return this;
		}
    }

	class LineWidthCellEditor extends SGSpinner implements TableCellEditor, ActionListener, 
			DocumentListener {
		
		private static final long serialVersionUID = 8601146413862351933L;

		public LineWidthCellEditor() {
			super();
	        this.initProperties(
	        		SGUtility.getLineWidthSpinnerNumberModel(),
	                LINE_WIDTH_UNIT, LINE_WIDTH_FRAC_DIGIT_MIN, LINE_WIDTH_FRAC_DIGIT_MAX);
	        this.getFormattedTextField().addActionListener(this);
	        this.getFormattedTextField().getDocument().addDocumentListener(this);
		}
		
		@Override
		public Component getTableCellEditorComponent(JTable table,
				Object value, boolean isSelected, int row, int column) {
			this.setValue(value);
			return this;
		}

		/**
		 * Overrode to set input value to the table.
		 * 
		 * @param value
		 *           a value to set
		 */
		@Override
		public void setValue(Object value) {
			super.setValue(value);
			final int row = mTable.getEditingRow();
			final int col = mTable.getEditingColumn();
			if (row != -1 && col != -1) {
				mTable.setValueAt(value, row, col);
			}
		}

		@Override
		public Object getCellEditorValue() {
			return this.getValue();
		}

		// Copied from AbstractCellEditor
		transient protected ChangeEvent changeEvent = null;

		@Override
		public boolean isCellEditable(java.util.EventObject e) {
			return true;
		}

		@Override
		public boolean shouldSelectCell(java.util.EventObject anEvent) {
			return true;
		}

		@Override
		public boolean stopCellEditing() {
			// reconstructs the parsed results
			if (this.mParsedResult == null) {
		        Object value = this.getValue();
		        StringBuffer sb = new StringBuffer();
		        sb.append(value);
		        sb.append(this.getSuffix());
		        this.mParsedResult = sb.toString();
			}
			this.setParsedResult();
			
			// updates the text string of the formatted text field
			this.getFormattedTextField().setText(this.mParsedResult);
			
			// clears the parsed result
			this.mParsedResult = null;
			
			fireEditingStopped();
			return true;
		}
		
		// Sets the parsed result to the table cell.
		private void setParsedResult() {
			Number num = this.parseStringToNumber(this.mParsedResult, MODE_DEFAULT);
			if (num != null) {
				this.setValue(num);
			}
		}

		@Override
		public void cancelCellEditing() {
			fireEditingCanceled();
		}

		@Override
		public void addCellEditorListener(CellEditorListener l) {
			listenerList.add(CellEditorListener.class, l);
		}

		@Override
		public void removeCellEditorListener(CellEditorListener l) {
			listenerList.remove(CellEditorListener.class, l);
		}

		public CellEditorListener[] getCellEditorListeners() {
			return (CellEditorListener[]) listenerList
					.getListeners(CellEditorListener.class);
		}

		protected void fireEditingStopped() {
			// Guaranteed to return a non-null array
			Object[] listeners = listenerList.getListenerList();
			// Process the listeners last to first, notifying
			// those that are interested in this event
			for (int i = listeners.length - 2; i >= 0; i -= 2) {
				if (listeners[i] == CellEditorListener.class) {
					// Lazily create the event:
					if (changeEvent == null)
						changeEvent = new ChangeEvent(this);
					((CellEditorListener) listeners[i + 1])
							.editingStopped(changeEvent);
				}
			}
		}

		protected void fireEditingCanceled() {
			// Guaranteed to return a non-null array
			Object[] listeners = listenerList.getListenerList();
			// Process the listeners last to first, notifying
			// those that are interested in this event
			for (int i = listeners.length - 2; i >= 0; i -= 2) {
				if (listeners[i] == CellEditorListener.class) {
					// Lazily create the event:
					if (changeEvent == null)
						changeEvent = new ChangeEvent(this);
					((CellEditorListener) listeners[i + 1])
							.editingCanceled(changeEvent);
				}
			}
		}

		@Override
		public void insertUpdate(DocumentEvent e) {
			this.documentUpdated(e);
		}

		@Override
		public void removeUpdate(DocumentEvent e) {
			this.documentUpdated(e);
		}

		@Override
		public void changedUpdate(DocumentEvent e) {
			this.documentUpdated(e);
		}
		
		private String mParsedResult = null;
		
		private void documentUpdated(DocumentEvent e) {
			Document doc = e.getDocument();
			try {
				String text = doc.getText(0, doc.getLength());
		        String parsedStr = this.parseString(text, MODE_DEFAULT);
		        this.mParsedResult = parsedStr;
			} catch (BadLocationException e1) {
			}
		}

		@Override
		public void actionPerformed(ActionEvent e) {
			this.setParsedResult();
		}
	}

	private void setLineTypeEditorComboBoxItems(JComboBox cb, String[] items, Object selectedItem) {
		cb.removeAllItems();
		for (int ii = 0; ii < items.length; ii++) {
			this.mLineTypeEditorComboBox.addItem(items[ii]);
		}
		this.mLineTypeEditorComboBox.setSelectedItem(selectedItem);
	}

    protected class LineTypeCellEditor extends DefaultCellEditor {
    	
		private static final long serialVersionUID = -4855548374127654502L;
		
		public LineTypeCellEditor(JComboBox comboBox) {
            super(comboBox);
        }
		
        public Component getTableCellEditorComponent(JTable table,
                Object value, boolean isSelected, int row, int column) {
            JComboBox cb = (JComboBox) super.getTableCellEditorComponent(table,
                    value, isSelected, row, column);
            setLineTypeEditorComboBoxItems(cb, SGILineConstants.LINE_NAME_ARRAY, value);
            return cb;
        }
    }

    protected class LineTypeCellRenderer extends DefaultTableCellRenderer {
    	
		private static final long serialVersionUID = 3534547450251620437L;
		
		private SGComboBox mComboBox = null;
		
        public LineTypeCellRenderer(JComboBox cb) {
            super();
            this.mComboBox = (SGComboBox) cb;
        }
        
        public Component getTableCellRendererComponent(JTable table,
                Object value, boolean isSelected, boolean hasFocus, int row,
                int column) {
            this.mComboBox.removeAllItems();
            this.mComboBox.addItem(value);
            return this.mComboBox;
        }
    }

    class LineColorCellRenderer extends SGColorSelectionButton implements TableCellRenderer {
    	
		private static final long serialVersionUID = -84819798505529225L;

		public LineColorCellRenderer() {
    		super();
    	}
    	
		@Override
		public Component getTableCellRendererComponent(JTable table,
				Object value, boolean isSelected, boolean hasFocus, int row,
				int column) {
			this.setColor((Color) value);
			this.setFocused(row == mColorSelectedRowIndex);
			repaint();
			return this;
		}
    }

    protected class LineStyleTableModel extends DefaultTableModel {
        
        private static final long serialVersionUID = 2213043296565029421L;

        public LineStyleTableModel() {
            super();
        }

        protected void addLineStyle(int index, SGLineStyle lineStyle) {
        	final int lineType = lineStyle.getLineType();
        	String strLineType = SGDrawingElementLine.getLineTypeName(lineType);
            Object[] array = { index + 1, "", lineStyle.getColor(), lineStyle.getLineWidth(), 
            		strLineType };
            super.addRow(array);
        }

        public int getColumnCount() {
            return COLUMN_NAME_ARRAY.length;
        }

        public String getColumnName(int index) {
            return COLUMN_NAME_ARRAY[index];
        }
        
        /**
         * Returns false for the column for column type.
         */
        public boolean isCellEditable(int row, int col) {
        	if (col == getColumnIndex(COLUMN_NAME_LINE_TYPE)
        			|| col == getColumnIndex(COLUMN_NAME_LINE_WIDTH)) {
        		return true;
        	} else {
            	return false;
        	}
        }
    }
    
    // Currently dragged row index.
    private int mDraggedRow = -1;

	@Override
	public void mouseClicked(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mTable)) {
			Point pos = e.getPoint();
			final int col = this.mTable.columnAtPoint(pos);
			if (col == this.getColumnIndex(COLUMN_NAME_LINE_COLOR)) {
				// sets clicked row index to the attribute
				final int row = this.mTable.rowAtPoint(pos);
				this.mColorSelectedRowIndex = row;
				
				// sets the color of clicked cell to the button
				Color color = (Color) this.mTable.getValueAt(row, col);
				this.mColorSelectionButton.setColor(color);
				
				// updates the current button
				this.mDialog.setCurrentColorButton(this.mColorSelectionButton);
				
				// shows a color selection dialog
				final int x = this.mDialog.getX() + 20;
				final int y = this.mDialog.getY() + 20;
				SGUtility.showColorSelectionDialog(this.mColorDialog, this.mColorSelectionButton,
						color, x, y);
			}
		}
	}
	
	@Override
	public void mousePressed(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mTable)) {
			Point pos = e.getPoint();
			final int row = this.mTable.rowAtPoint(pos);
			this.mDraggedRow = row;
		}
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mTable)) {
			this.mDraggedRow = -1;
		}
	}

	@Override
	public void mouseEntered(MouseEvent e) {
	}

	@Override
	public void mouseExited(MouseEvent e) {
	}

	@Override
	public void mouseDragged(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mTable)) {
			Point pos = e.getPoint();
			final int row = this.mTable.rowAtPoint(pos);
			if (row != -1) {
				this.mTableModel.moveRow(this.mDraggedRow, this.mDraggedRow, row);
				this.mDraggedRow = row;
			}
		}
	}

	@Override
	public void mouseMoved(MouseEvent e) {
	}

    public Boolean isReversedOrder() {
        return this.mReversedOrderCheckBox.getSelected();
    }

    public boolean setReversedOrder(final Boolean b) {
        this.mReversedOrderCheckBox.setSelected(b);
        this.mColorMapRendererPanel.setReversedOrder(b);
        return true;
    }
    
    public boolean isLineColorAutoAssigned() {
    	return this.mLineColorAutoAssigned;
    }

    public void setLineColorAutoAssigned(final boolean b) {
    	this.mLineColorAutoAssigned = b;
    }

}
