package jp.riken.brain.ni.samuraigraph.application;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.swing.JScrollBar;
import javax.swing.JTable;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableColumn;

import jp.riken.brain.ni.samuraigraph.application.SGMainFunctions.DataReloadResult;
import jp.riken.brain.ni.samuraigraph.application.SGMainFunctions.DataReloadResultSet;
import jp.riken.brain.ni.samuraigraph.base.SGIConstants;
import jp.riken.brain.ni.samuraigraph.base.SGTable;

/**
 * The panel to display the result of reloading data.
 * 
 */
public class SGDataReloadResultPanel extends javax.swing.JPanel 
	implements ComponentListener, MouseWheelListener, SGIApplicationConstants {

	private static final long serialVersionUID = 5922400604249692824L;

	/** Creates new form SGDataReloadResultPanel */
    public SGDataReloadResultPanel() {
    	super();
        initComponents();
        this.initProperty();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mTableScrollPane = new javax.swing.JScrollPane();
        mTable = this.createTableInstance();
        mMessageLabel = new javax.swing.JLabel();

        setLayout(new java.awt.GridBagLayout());

        mTableScrollPane.setBorder(null);
        mTableScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        mTableScrollPane.setFont(new java.awt.Font("Dialog", 0, 11)); // NOI18N
        mTableScrollPane.setPreferredSize(new java.awt.Dimension(434, 160));

        mTable.setFont(new java.awt.Font("Dialog", 0, 11)); // NOI18N
        mTableScrollPane.setViewportView(mTable);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        add(mTableScrollPane, gridBagConstraints);

        mMessageLabel.setFont(new java.awt.Font("Dialog", 0, 18)); // NOI18N
        mMessageLabel.setText("Failed to reload data.");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 5, 0);
        add(mMessageLabel, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel mMessageLabel;
    protected jp.riken.brain.ni.samuraigraph.base.SGTable mTable;
    private javax.swing.JScrollPane mTableScrollPane;
    // End of variables declaration//GEN-END:variables

	public static final String COLUMN_NAME_NUMBER = "No";

	public static final String COLUMN_NAME_FILE_LOCATION = "Location";

	public static final String COLUMN_NAME_MESSAGE = "Message";

	public static final String[] COLUMN_NAME_ARRAY = { COLUMN_NAME_NUMBER,
			COLUMN_NAME_FILE_LOCATION, COLUMN_NAME_MESSAGE };

    private static final int[] PREFERRED_COLUMN_WIDTH_ARRAY = { 10, 160, 120 };
	
    /**
     * Initialize this panel.
     */
    private void initProperty() {
    	
        // initialize the table model
        this.initTableModel();
        
        // add the table as a mouse wheel listener
        this.mTable.addMouseWheelListener(this);
        
        // set up the scroll bar properties
        JScrollBar vertBar = this.mTableScrollPane.getVerticalScrollBar();
        vertBar.setUnitIncrement(SGIConstants.SCROLL_BAR_UNIT_INCREMENT);
        vertBar.setBlockIncrement(SGIConstants.SCROLL_BAR_BLOCK_INCREMENT);
        
        this.addComponentListener(this);
        
        for (int ii = 0; ii < COLUMN_NAME_ARRAY.length; ii++) {
            TableColumn cl = this.mTable.getColumn(COLUMN_NAME_ARRAY[ii]);
            cl.setCellRenderer(new DataColumnCellRenderer());
        }
    }
    
    // Updates the column width.
    private void updateColumnWidth() {
        for (int ii = 0; ii < COLUMN_NAME_ARRAY.length; ii++) {
            TableColumn cl = this.mTable.getColumn(COLUMN_NAME_ARRAY[ii]);
            cl.setPreferredWidth(PREFERRED_COLUMN_WIDTH_ARRAY[ii]);
        }
    }

    /**
     * Initializes the table model.
     */
    protected void initTableModel() {
        DefaultTableModel model = new DefaultTableModel();
        model.setColumnIdentifiers(COLUMN_NAME_ARRAY);
        this.mTable.setModel(model);
    }
    
    /**
     * Creates and returns a table object.
     * 
     * @return a table object
     */
    protected SGTable createTableInstance() {
    	return new SGTable(){
			private static final long serialVersionUID = 8363166747469148328L;

			@Override
			public boolean isCellEditable(int row, int column) {
				return false;
			}
        };
    }

    /**
     * Scroll the vertical scroll bar.
     */
    public void mouseWheelMoved(MouseWheelEvent e) {
        final int amount = e.getScrollAmount() * e.getWheelRotation();
        JScrollBar vertBar = this.mTableScrollPane.getVerticalScrollBar();
        final int value = vertBar.getValue() + amount * 6;
        vertBar.setValue(value);
    }
    
    private List<Integer> mErrorIndexList = new ArrayList<Integer>();
    
    /**
     * Sets the result of reloading data to the table.
     * 
     * @param results
     *           the results to set
     */
    public void setResult(final DataReloadResultSet results) {
    	if (results == null) {
    		throw new IllegalArgumentException("results == null");
    	}
    	Map<String, DataReloadResult> map = results.getMap();
    	Set<Entry<String, DataReloadResult>> entrySet = map.entrySet();
    	int cnt = 0;
    	for (Entry<String, DataReloadResult> e : entrySet) {
    		final String index = Integer.toString(cnt + 1);
    		final String filePath = e.getKey();
    		final DataReloadResult result = e.getValue();
    		final RELOAD_DATA_STATUS status = result.getStatus();
    		String message = "";
			switch (status) {
			case SUCCEEDED:
				message = "Succeeded.";
				break;
			case LOST:
				message = "Data file is not found.";
	    		this.mErrorIndexList.add(cnt);
				break;
			case INVALID_DATA:
				message = "Invalid data.";
	    		this.mErrorIndexList.add(cnt);
				break;
			default:
				break;
			}

    		Object[] rowData = {index, filePath, message};
    		DefaultTableModel model = (DefaultTableModel) this.mTable.getModel();
    		model.addRow(rowData);
    		cnt++;
    	}
    }

	protected class DataColumnCellRenderer extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -3636877835153226638L;

		public Component getTableCellRendererComponent(JTable tb, Object val,
				boolean isSelected, boolean hasFocus, int r, int c) {
			if (mErrorIndexList.contains(r)) {
				this.setForeground(Color.RED);
			} else {
				this.setForeground(Color.BLACK);
			}
			return super.getTableCellRendererComponent(tb, val, isSelected,
					hasFocus, r, c);
		}

	}

	@Override
	public void componentResized(ComponentEvent e) {
		this.updateColumnWidth();
	}

	@Override
	public void componentMoved(ComponentEvent e) {
	}

	@Override
	public void componentShown(ComponentEvent e) {
		this.updateColumnWidth();
	}

	@Override
	public void componentHidden(ComponentEvent e) {
	}
    
}
