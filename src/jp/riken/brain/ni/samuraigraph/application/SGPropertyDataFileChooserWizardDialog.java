package jp.riken.brain.ni.samuraigraph.application;

import java.awt.Color;
import java.awt.Component;
import java.awt.Insets;
import java.awt.Point;
import java.awt.dnd.DnDConstants;
import java.awt.dnd.DropTarget;
import java.awt.dnd.DropTargetDragEvent;
import java.awt.dnd.DropTargetDropEvent;
import java.awt.dnd.DropTargetEvent;
import java.awt.dnd.DropTargetListener;
import java.awt.event.ActionEvent;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.prefs.Preferences;

import javax.swing.AbstractCellEditor;
import javax.swing.BorderFactory;
import javax.swing.DefaultCellEditor;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.JScrollBar;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.JViewport;
import javax.swing.SwingUtilities;
import javax.swing.event.CellEditorListener;
import javax.swing.event.ChangeEvent;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableModel;

import jp.riken.brain.ni.samuraigraph.application.SGDataCreator.FileColumn;
import jp.riken.brain.ni.samuraigraph.application.SGDataCreator.SDArrayFileParseResult;
import jp.riken.brain.ni.samuraigraph.application.SGIApplicationConstants.FILE_TYPE;
import jp.riken.brain.ni.samuraigraph.base.SGButton;
import jp.riken.brain.ni.samuraigraph.base.SGDataColumnInfo;
import jp.riken.brain.ni.samuraigraph.base.SGDataColumnInfoSet;
import jp.riken.brain.ni.samuraigraph.base.SGIConstants;
import jp.riken.brain.ni.samuraigraph.base.SGIntegerSeriesSet;
import jp.riken.brain.ni.samuraigraph.base.SGTable;
import jp.riken.brain.ni.samuraigraph.base.SGTuple2f;
import jp.riken.brain.ni.samuraigraph.base.SGUtility;
import jp.riken.brain.ni.samuraigraph.data.SGDataTypeConstants;
import jp.riken.brain.ni.samuraigraph.data.SGDataUtility;
import jp.riken.brain.ni.samuraigraph.data.SGHDF5File;
import jp.riken.brain.ni.samuraigraph.data.SGIDataColumnTypeConstants;
import jp.riken.brain.ni.samuraigraph.data.SGIDataInformationKeyConstants;
import jp.riken.brain.ni.samuraigraph.data.SGMATLABFile;
import jp.riken.brain.ni.samuraigraph.data.SGMDArrayFile;
import jp.riken.brain.ni.samuraigraph.data.SGMDArrayVariable;
import jp.riken.brain.ni.samuraigraph.data.SGNetCDFFile;
import jp.riken.brain.ni.samuraigraph.data.SGNetCDFVariable;
import jp.riken.brain.ni.samuraigraph.data.SGSDArrayFile;
import ucar.nc2.NetcdfFile;
import ch.systemsx.cisd.hdf5.IHDF5Reader;

import com.jmatio.io.MatFileReader;

/**
 * A dialog to choose multiple data files for the property file.
 * 
 */
public class SGPropertyDataFileChooserWizardDialog extends SGWizardDialog
        implements TableModelListener, DropTargetListener, ComponentListener,
        CellEditorListener, MouseListener, MouseMotionListener,
        MouseWheelListener, SGIDataColumnTypeConstants {

    /**
     * Serial Version UID.
     */
    private static final long serialVersionUID = 1614748084851553730L;

    /**
     * The title of this dialog.
     */
    public static final String TITLE = "Select the Data Files";

    /**
     * The default constructor.
     */
    public SGPropertyDataFileChooserWizardDialog() {
        super();
        initComponents();
        this.initProperty();
    }

    /** Creates new form SGDataFileChooseWizardDialog */
    public SGPropertyDataFileChooserWizardDialog(java.awt.Frame parent,
            boolean modal) {
        super(parent, modal);
        initComponents();
        this.initProperty();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mPanel = new javax.swing.JPanel();
        mScrollPane = new javax.swing.JScrollPane();
        mTable = this.createTableInstance();
        mButtonPanel = new javax.swing.JPanel();
        mPreviousButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();
        mNextButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();
        mOKButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();
        mCancelButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();

        getContentPane().setLayout(new java.awt.GridBagLayout());

        mPanel.setFont(new java.awt.Font("SansSerif", 0, 11));
        mPanel.setLayout(new java.awt.GridBagLayout());

        mScrollPane.setFont(new java.awt.Font("Dialog", 0, 11));
        mScrollPane.setPreferredSize(new java.awt.Dimension(468, 200));

        mTable.setFont(new java.awt.Font("Dialog", 0, 11));
        mScrollPane.setViewportView(mTable);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(4, 0, 0, 0);
        mPanel.add(mScrollPane, gridBagConstraints);

        getContentPane().add(mPanel, new java.awt.GridBagConstraints());

        mButtonPanel.setFont(new java.awt.Font("Dialog", 0, 11));

        mPreviousButton.setText("<Prev");
        mPreviousButton.setFont(new java.awt.Font("Dialog", 1, 12));
        mButtonPanel.add(mPreviousButton);

        mNextButton.setText("Next>");
        mNextButton.setFont(new java.awt.Font("Dialog", 1, 12));
        mButtonPanel.add(mNextButton);

        mOKButton.setText("OK");
        mOKButton.setFont(new java.awt.Font("Dialog", 1, 12));
        mButtonPanel.add(mOKButton);

        mCancelButton.setText("Cancel");
        mCancelButton.setFont(new java.awt.Font("Dialog", 1, 12));
        mButtonPanel.add(mCancelButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 0, 0, 0);
        getContentPane().add(mButtonPanel, gridBagConstraints);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel mButtonPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mCancelButton;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mNextButton;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mOKButton;
    private javax.swing.JPanel mPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mPreviousButton;
    private javax.swing.JScrollPane mScrollPane;
    protected jp.riken.brain.ni.samuraigraph.base.SGTable mTable;
    // End of variables declaration//GEN-END:variables

    /**
     * Name of the column for the figure ID.
     */
    public static final String COLUMN_NAME_FIGURE_ID = "Figure ID";

    /**
     * Name of the column for the data type.
     */
    public static final String COLUMN_NAME_DATA_TYPE = "Data Type";

    /**
     * Name of the column for the data name.
     */
    public static final String COLUMN_NAME_DATA_NAME = "Data Name";

    /**
     * Name of the column for the file name.
     */
    public static final String COLUMN_NAME_FILE_NAME = "File Name";

    /**
     * Name of the column for the file name.
     */
    public static final String COLUMN_NAME_BUTTON = "";

    /**
     * A string to represent no data.
     */
    public static final String NO_DATA = "NO_DATA";

    /**
     * An array of column name.
     */
    public static final String[] COLUMN_NAME_ARRAY = { COLUMN_NAME_FIGURE_ID,
            COLUMN_NAME_DATA_TYPE, COLUMN_NAME_DATA_NAME, COLUMN_NAME_FILE_NAME,
            COLUMN_NAME_BUTTON };

    /**
     * A constant array of column width.
     */
    private static final int[] PREFERRED_COLUMN_WIDTH_ARRAY = { 50, 80, 80, 120, 20 };

    /**
     * The table model.
     */
    private DefaultTableModel mTableModel = null;

    /**
     * An array of data files.
     */
    private DataFile[] mDataFileArray = null;
    
    /**
     * Data creator.
     */
    private SGDataCreator mDataCreator = null;

    /**
     * A dialog to setup the data columns.
     */
    private SGPropertyFileDataDialog mPropertyFileDataDialog = null;

    /**
     * A dialog to select the data file.
     */
    private SGSingleDataFileChooserWizardDialog mSingleDataFileChooserWizardDilaog = null;
    
    /**
     * The row index setting up the data file or URL.
     */
    private int mCurDataSetupRowIndex = -1;

    /**
     * The row index currently focused.
     */
    private int mFocusedRowIndex = -1;

    /**
     * The version number of the property file.
     */
    private String mVersionNumber = null;

    /**
     * Initialize this dialog.
     */
    private boolean initProperty() {
    	
        // set the title
        this.setTitle(SGPropertyDataFileChooserWizardDialog.TITLE);

        // table model
        this.mTableModel = new OriginalTableModel();
        this.mTable.setModel(this.mTableModel);
        this.mTableModel.addTableModelListener(this);

        // data creator
        this.mDataCreator = new SGDataCreator();

        // drag and drop
        DropTarget target = new DropTarget(this.mTable,
                DnDConstants.ACTION_COPY_OR_MOVE, this, true);
        this.setDropTarget(target);

        // add the table as an event listener
        this.mTable.addComponentListener(this);
        this.mTable.addMouseListener(this);
        this.mTable.addMouseMotionListener(this);
        this.mTable.addMouseWheelListener(this);

        // set up the scroll bar properties
        JScrollBar vertBar = this.mScrollPane.getVerticalScrollBar();
        vertBar.setUnitIncrement(SGIConstants.SCROLL_BAR_UNIT_INCREMENT);
        vertBar.setBlockIncrement(SGIConstants.SCROLL_BAR_BLOCK_INCREMENT);
        
        return true;
    }

    /**
     * 
     */
    public void componentResized(ComponentEvent e) {
        super.componentResized(e);
        this.updateTable();
    }

    /**
     * 
     */
    public void componentShown(ComponentEvent e) {
        super.componentShown(e);
        this.updateTable();
    }

    private void updateTable() {
        final int height = this.mTable.getHeight();
        if (height != 0) {
            this.setPreferredColumnWidth();
        }
    }

    /**
     * Returns the number of data.
     *
     * @return the number of data
     */
    public int getDataNum() {
        if (this.mDataFileArray == null) {
            return 0;
        } else {
            return this.mDataFileArray.length;
        }
    }

    /**
     * A class for a single data file.
     */
    private class DataFile {
        int figureId = -1;

        String dataType = null;

        String dataName = null;

        String fileName = null;

        Map<String, Object> infoMap = new HashMap<String, Object>();
        
        SGTuple2f figureSize = null;

        SGDataColumnInfoSet dataColInfoSet = null;
        
        boolean hasData = true;

        DataFile(int figureId, SGTuple2f figureSize,
        		String dataType, String dataName, Map<String, Object> infoMap) {
            this.figureId = figureId;
            this.figureSize = figureSize;
            this.dataType = dataType;
            this.dataName = dataName;
            this.infoMap = infoMap;
        }
    }

    /**
     * Returns an array of property file data.
     *
     * @return an array of property file data
     */
    public SGPropertyFileData[] getPropertyFileDataArray() {
        final int dataNum = this.getDataNum();
        SGPropertyFileData[] pFile = new SGPropertyFileData[dataNum];
        for (int ii = 0; ii < dataNum; ii++) {
            DataFile df = this.mDataFileArray[ii];
            pFile[ii] = new SGPropertyFileData(df.figureId, df.dataType,
                    df.dataName, df.infoMap);
            pFile[ii].setColumnInfoSet(df.dataColInfoSet);
            pFile[ii].setFileName(df.fileName);
        }
        return pFile;
    }

    /**
     *
     */
    public void actionPerformed(final ActionEvent e) {

        Object source = e.getSource();
        String command = e.getActionCommand();

        // an event from the data column selection dialog
        if (source.equals(this.mPropertyFileDataDialog)) {
            
            if (command.equals(OK_BUTTON_TEXT)) {
                // get an array of data column information for the current
                // data file and set it to an attribute
                SGPropertyFileDataDialog dg = (SGPropertyFileDataDialog) source;
                String fileName = dg.getFileName();
                SGDataColumnInfoSet colInfoSet = dg.getDataColumnInfoSet();
                DataFile dataFile = this.mDataFileArray[this.mCurDataSetupRowIndex];
                dataFile.dataColInfoSet = colInfoSet;
                dataFile.fileName = fileName;
                
                SGPropertyFileDataDialog fdg = (SGPropertyFileDataDialog) dg;
                final String dataType = fdg.getDataType();
                final boolean strideAvailable = fdg.isStrideAvailable();
                final Map<String, SGIntegerSeriesSet> strideMap = fdg.getStrideMap();
                
                // set to the information map
                Map<String, Object> infoMap = dataFile.infoMap;
                infoMap.put(SGIDataInformationKeyConstants.KEY_DATA_TYPE, dataType);
                infoMap.put(SGIDataInformationKeyConstants.KEY_STRIDE_AVAILABLE, strideAvailable);
                infoMap.put(SGIDataInformationKeyConstants.KEY_ALL_STRIDE, strideMap);

                if (this.mPropertyFileDataDialog instanceof SGPropertyFileSDArrayDataDialog) {
                	// SDAray
                    
                } else if (this.mPropertyFileDataDialog instanceof SGPropertyFileNetCDFDataDialog) {
                	// NetCDF
                    SGPropertyFileNetCDFDataDialog ndg = (SGPropertyFileNetCDFDataDialog) dg;
                    
                    SGIntegerSeriesSet pickUpIndices = ndg.getSXYPickUpIndices();
                    final boolean multipleVariable = (pickUpIndices == null);
                    
                    // set to the information map
                    infoMap.put(SGIDataInformationKeyConstants.KEY_SXY_MULTIPLE_VARIABLE, multipleVariable);
                    if (pickUpIndices != null) {
                        infoMap.put(SGIDataInformationKeyConstants.KEY_SXY_PICKUP_INDICES, pickUpIndices);
                    }
                    
                } else if (this.mPropertyFileDataDialog instanceof SGPropertyFileMDArrayDataDialog) {
                	// MDArray
                    SGPropertyFileMDArrayDataDialog mdg = (SGPropertyFileMDArrayDataDialog) dg;
                    
                    List<String> datasetName = mdg.getSXYDataPickUpDatasetName();
                    Map<String, Integer> pickUpDimensionMap = mdg.getSXYDataPickUpDimensionIndexMap();
                    SGIntegerSeriesSet pickUpIndices = mdg.getSXYPickUpIndices();
                    Map<String, Integer> timeDimensionMap = mdg.getTimeDimensionIndexMap();
                    final boolean multipleVariable = (datasetName == null);
                    
                    // set to the information map
                    infoMap.put(SGIDataInformationKeyConstants.KEY_SXY_MDARRAY_PICKUP_DIMENSION_INDEX_MAP, pickUpDimensionMap);
                    infoMap.put(SGIDataInformationKeyConstants.KEY_SXY_PICKUP_INDICES, pickUpIndices);
                    infoMap.put(SGIDataInformationKeyConstants.KEY_SXY_MULTIPLE_VARIABLE, multipleVariable);
                    infoMap.put(SGIDataInformationKeyConstants.KEY_TIME_DIMENSION_INDEX_MAP, timeDimensionMap);
                } else {
                	throw new Error("This must not happen.");
                }
                
                // set to the table
                final int colIndexFileName = this.getFileNameColumnIndex();
                this.mTable.setValueAt(fileName, this.mCurDataSetupRowIndex, colIndexFileName);

                // update the buttons
                this.updateAvailableButtons();
            } else if (command.equals(CANCEL_BUTTON_TEXT)) {
                if (this.mSingleDataFileChooserWizardDilaog!=null) {
                    this.mSingleDataFileChooserWizardDilaog.setVisible(true);
                }
            }
            this.mCurDataSetupRowIndex = -1;
            
        } else if (source.equals(this.mSingleDataFileChooserWizardDilaog)) {
            
            if (command.equals(OK_BUTTON_TEXT)) {
                if (this.mSingleDataFileChooserWizardDilaog==null) {
                    return;
                }
                this.mSingleDataFileChooserWizardDilaog.setVisible(false);

                // selected data file object
                DataFile dataFile = mDataFileArray[this.mCurDataSetupRowIndex];
                String dataType = dataFile.dataType;
                Map<String, Object> infoMap = dataFile.infoMap;
                SGDataColumnInfoSet dataColumnInfoSet = dataFile.dataColInfoSet;
                SGTuple2f figureSize = dataFile.figureSize;
                infoMap.put(SGIDataInformationKeyConstants.KEY_FIGURE_SIZE, figureSize);
                String fileName = this.mSingleDataFileChooserWizardDilaog.getFileName();
                if (this.showPropertyFileDataDialog(
                        fileName, dataType, dataColumnInfoSet, infoMap) == false) {
                	
                	// shows an error message dialog
                	SGApplicationUtility.showDataFileInvalidMessageDialog(this.getOwner());
                	
                	// shows a dialog again
                    this.mSingleDataFileChooserWizardDilaog.setVisible(true);
                }
            }
        }

        // calls the method of the super class
        super.actionPerformed(e);
    }

    public void mouseDragged(MouseEvent e) {
    }

    public void mouseMoved(MouseEvent e) {
    }

    /**
     * Scroll the vertical scroll bar.
     */
    public void mouseWheelMoved(MouseWheelEvent e) {
        final int amount = e.getScrollAmount() * e.getWheelRotation();
        JScrollBar vertBar = this.mScrollPane.getVerticalScrollBar();
        final int value = vertBar.getValue() + amount * 6;
        vertBar.setValue(value);
    }

    /**
     * Returns the column index of table.
     *
     * @param identifier
     * @return If the column with given identifier exists, returns the index.
     */
    public int getColumnIndex(final String identifier) {
        return this.mTable.getColumnModel().getColumnIndex(identifier);
    }

    /**
     * Called when the table has changed.
     */
    public void tableChanged(TableModelEvent e) {

        final int type = e.getType();
        if (type == TableModelEvent.UPDATE) {

            // if the first row does not exist, return now
            if (e.getFirstRow() == -1) {
                return;
            }
            final int firstRow = e.getFirstRow();

            // check whether all input file exists
            final int colIndex = this.getFileNameColumnIndex();
            Object obj = this.mTableModel.getValueAt(firstRow, colIndex);
            if (obj != null && this.mDataFileArray[firstRow].hasData == false) {
                String str = (String) obj;
                File f = new File(str);

                // set selected file
                this.setSelectedFile(firstRow, f.getPath());

                // update the buttons
                this.updateAvailableButtons();
            }
        }
    }

    /**
     * Update available buttons: the OK button and file selection buttons.
     */
    private void updateAvailableButtons() {

        boolean enableOK = true;
        final int colIndex = this.getFileNameColumnIndex();

        // check all cells in file name column
        for (int ii = 0; ii < this.mDataFileArray.length; ii++) {
            if (this.mDataFileArray[ii].hasData == false) {
                continue;
            }
            String fileName = (String) this.mTableModel.getValueAt(ii, colIndex);
            if (fileName == null || fileName.trim().equals("")) {
                enableOK = false;
                break;
            }
            FILE_TYPE type = SGApplicationUtility.identifyDataFileType(fileName);
            if (FILE_TYPE.NETCDF_DATA.equals(type) == false) {
                File file = new File(fileName);
                if (this.isAcceptable(file)) {
                    enableOK = true;
                } else {
                    enableOK = false;
                    break;
                }
            }
        }

        // update the OK button
        this.mOKButton.setEnabled(enableOK);
    }

    /**
     *
     */
    public JTable getTable() {
        return this.mTable;
    }

    /**
     *
     */
    public TableModel getTableModel() {
        return this.mTable.getModel();
    }

    /**
     *
     */
    public boolean setTableModel(final TableModel model) {
        JTable table = this.mTable;
        table.setModel(model);
        return true;
    }

    /**
     *
     * @return
     */
    public int getFigureIDColumnIndex() {
        return this.getColumnIndex(COLUMN_NAME_FIGURE_ID);
    }

    /**
     *
     * @return
     */
    public int getDataNameColumnIndex() {
        return this.getColumnIndex(COLUMN_NAME_DATA_NAME);
    }

    /**
     *
     * @return
     */
    public int getDataTypeColumnIndex() {
        return this.getColumnIndex(COLUMN_NAME_DATA_TYPE);
    }

    /**
     *
     * @return
     */
    public int getFileNameColumnIndex() {
        return this.getColumnIndex(COLUMN_NAME_FILE_NAME);
    }

    /**
    *
    * @return
    */
   public int getButtonColumnIndex() {
       return this.getColumnIndex(COLUMN_NAME_BUTTON);
   }

    /**
     * Sets the data column information.
     *
     * @param dataList
     *            a list of data column information
     * @param versionNumber
     *            the version number of property file
     */
    @SuppressWarnings("unchecked")
	public void setData(List<SGPropertyFileData> dataList, String versionNumber) {
        
        // set to attribute
        this.mVersionNumber = versionNumber;

        // the number of data
        final int dataNum = dataList.size();

        // initialize the table
        this.initTable(dataNum);

        // create arrays
        int[] idArray = new int[dataNum];
        String[] typeArray = new String[dataNum];
        String[] nameArray = new String[dataNum];
        String[] fileArray = new String[dataNum];
        SGButton[] btnArray = new SGButton[dataNum];
        Map<String, Object>[] mapArray = new Map[dataNum];
        SGTuple2f[] figureSizeArray = new SGTuple2f[dataNum];
        for (int ii = 0; ii < dataNum; ii++) {
            SGPropertyFileData data = dataList.get(ii);
            idArray[ii] = data.getFigureId();
            String type = data.getDataType();
            if (type != null) {
                typeArray[ii] = type;
                nameArray[ii] = data.getDataName();
                fileArray[ii] = "";
            } else {
                typeArray[ii] = "";
                nameArray[ii] = "";
                fileArray[ii] = NO_DATA;
            }
            btnArray[ii] = new SGButton(" ");
            mapArray[ii] = new HashMap<String, Object>(data.getInfoMap());
            figureSizeArray[ii] = data.getFigureSize();
        }

        // create an array
        this.mDataFileArray = new DataFile[dataNum];
        for (int ii = 0; ii < dataNum; ii++) {
            this.mDataFileArray[ii] = new DataFile(idArray[ii], figureSizeArray[ii],
            		typeArray[ii], nameArray[ii], mapArray[ii]);
            this.mDataFileArray[ii].hasData = !(NO_DATA.equals(fileArray[ii]));
        }

        // set to the table
        final int idColIndex = this.getFigureIDColumnIndex();
        final int typeColIndex = this.getDataTypeColumnIndex();
        final int nameColIndex = this.getDataNameColumnIndex();
        final int fileColIndex = this.getFileNameColumnIndex();
        final int btnColIndex = this.getButtonColumnIndex();
        for (int ii = 0; ii < dataNum; ii++) {
            this.mTable.setValueAt(Integer.toString(idArray[ii]), ii,
                    idColIndex);
            String type = SGDataTypeConstants.getLongDataTypeConstant(typeArray[ii]);
            this.mTable.setValueAt(type, ii, typeColIndex);
            this.mTable.setValueAt(nameArray[ii], ii, nameColIndex);
            this.mTable.setValueAt(fileArray[ii], ii, fileColIndex);
            this.mTable.setValueAt(btnArray[ii], ii, btnColIndex);
            this.mTable.getCellEditor(ii, fileColIndex).addCellEditorListener(this);
        }

        // update the buttons
        this.updateAvailableButtons();
    }

    /**
     * Set size of columns.
     *
     */
    private void setPreferredColumnWidth() {
        JTable table = this.mTable;
        final int[] size = PREFERRED_COLUMN_WIDTH_ARRAY;
        for (int ii = 0; ii < COLUMN_NAME_ARRAY.length; ii++) {
            TableColumn cl = table.getColumn(COLUMN_NAME_ARRAY[ii]);
            cl.setPreferredWidth(size[ii]);
        }
    }

    /**
     * Initialize the table.
     */
    private void initTable(final int dataNumber) {
        
        // init the table model
        Object[][] data = new Object[dataNumber][];
        final int len = COLUMN_NAME_ARRAY.length;
        for (int ii = 0; ii < data.length; ii++) {
            data[ii] = new Object[len];
        }
        this.mTableModel.setDataVector(data, COLUMN_NAME_ARRAY);
        
        // set up the column with buttons
        final int colIndexButton = this.getColumnIndex(COLUMN_NAME_BUTTON);
        TableColumn colButton = this.mTable.getColumnModel().getColumn(
                colIndexButton);
        ButtonColumn bcol = new ButtonColumn();
        colButton.setMinWidth(SGTable.ROW_HEIGHT);
        colButton.setMaxWidth(SGTable.ROW_HEIGHT);
        colButton.setResizable(false);
        colButton.setCellEditor(bcol);
        colButton.setCellRenderer(bcol);
        
        // set up the column for file names
        final int colIndexFileName = this.getColumnIndex(COLUMN_NAME_FILE_NAME);
        TableColumn colFileName = this.mTable.getColumnModel().getColumn(
                colIndexFileName);
        JTextField textField = new JTextField();
        textField.setBorder(BorderFactory.createEmptyBorder());
        FileNameColumnCellEditor fcolEditor = new FileNameColumnCellEditor(textField);
        colFileName.setCellEditor(fcolEditor);
        FileNameColumnCellRenderer fcolRenderer = new FileNameColumnCellRenderer();
        colFileName.setCellRenderer(fcolRenderer);
    }

    /**
     * Returns a TreeMap object of figure ID to a list of property file data.
     *
     * @return a tree map object
     */
    public TreeMap<Object, Object> getSelectedFilePathListMap() {

        final int idColIndex = this.getFigureIDColumnIndex();
        final int nameColIndex = this.getFileNameColumnIndex();

        TreeMap<Object, Object> map = new TreeMap<Object, Object>();
        final int rowCount = this.mTable.getRowCount();
        for (int ii = 0; ii < rowCount; ii++) {
            // figure ID
            Object id = this.mTable.getValueAt(ii, idColIndex);

            // list of the path of data files
            Object obj = map.get(id);
            if (obj == null) {
                obj = new ArrayList();
                map.put(id, obj);
            }
            ArrayList<Object> list = (ArrayList<Object>) obj;

            // add the path to the list
            Object name = this.mTable.getValueAt(ii, nameColIndex);
            list.add(name);
        }

        return map;
    }

    /**
     *
     */
    public String[] getSelectedFileNames() {
        JTable table = this.getTable();
        final int col = this.getFileNameColumnIndex();
        final int num = table.getRowCount();
        String[] array = new String[num];
        for (int ii = 0; ii < num; ii++) {
            array[ii] = (String) table.getValueAt(ii, col);
        }
        return array;
    }

    protected JButton getPreviousButton() {
        return this.mPreviousButton;
    }

    protected JButton getNextButton() {
        return this.mNextButton;
    }

    protected JButton getOKButton() {
        return this.mOKButton;
    }

    protected JButton getCancelButton() {
        return this.mCancelButton;
    }

    /**
     *
     */
    public void dragEnter(final DropTargetDragEvent dtde) {
        dtde.acceptDrag(DnDConstants.ACTION_COPY_OR_MOVE);
    }

    /**
     *
     */
    public void dragExit(final DropTargetEvent dte) {
    }

    /**
     *
     */
    public void dragOver(final DropTargetDragEvent dtde) {
    }

    /**
     *
     */
    public void drop(final DropTargetDropEvent dtde) {

        JTable table = this.mTable;
        JTableHeader header = table.getTableHeader();
        JViewport vp = this.mScrollPane.getViewport();
        Point vpPos = vp.getViewPosition();
        Point location = dtde.getLocation();
        Insets ins = this.getInsets();
        final int originX = ins.left - vpPos.x;
        final int originY = ins.top + this.mScrollPane.getY() - vpPos.y
                + header.getHeight();
        final Point pos = new Point(location.x - originX, location.y - originY);
        final int column = this.getFileNameColumnIndex();

        // get the row index
        final int rowIndex = table.rowAtPoint(pos);
        if (rowIndex == -1) {
            return;
        }

        // if dropped onto a row with no data, returns now
        if (this.mDataFileArray[rowIndex].hasData == false) {
            return;
        }

        // get dropped file list
        List fileList = SGApplicationUtility.getDroppedFileList(dtde);
        if (fileList == null || fileList.size() == 0) {
            return;
        }

        // get only the first file
        File file = (File) fileList.get(0);

        // set the value to the cell
        table.setValueAt(file.getPath(), rowIndex, column);

        // set the selected file
        this.setSelectedFile(rowIndex, file.getPath());

        // update the buttons
        this.updateAvailableButtons();
    }

    /**
     * Called when some string has input to the cell for the file name.
     * @param rowIndex
     *                the row index
     * @param f
     *                a file object created with an input string
     */
    private void setSelectedFile(final int rowIndex, final String path) {
        // for different file
        if (path.equals(this.mDataFileArray[rowIndex].fileName) == false) {
            
            // set to attributes
            this.mDataFileArray[rowIndex].fileName = path;
            
            // clear attributes
            this.mDataFileArray[rowIndex].dataColInfoSet = null;
        }
    }

    /**
     * Returns whether a given file is acceptable as a property file.
     * @param f
     *         a file
     * @return
     *         true if a given file is acceptable
     */
    protected boolean isAcceptable(File f) {
        // the file exists and is a file
        return (f.exists()) && (f.isFile());
    }

    /**
     *
     */
    public void dropActionChanged(final DropTargetDragEvent dtde) {
    }

    /**
     * The original table model.
     */
    private class OriginalTableModel extends DefaultTableModel {

        /**
         * Serial Version UID.
         */
        private static final long serialVersionUID = -7588229760968586164L;

        public OriginalTableModel() {
            super();
        }

        public boolean isCellEditable(int rowIndex, int columnIndex) {
            JTable table = mTable;
            String name = table.getColumnName(columnIndex);
            boolean b = true;
            if (name.equals(COLUMN_NAME_FILE_NAME)) {
                if (mDataFileArray[rowIndex].hasData == false) {
                    b = false;
                }
            } else {
                b = false;
            }
            return b;
        }

    }


    /**
     * Cell editor class for a column with a button.
     *
     */
    private class ButtonColumn extends AbstractCellEditor implements
            TableCellRenderer, TableCellEditor {

        private static final long serialVersionUID = 4671694450428631643L;
        private static final String BUTTON_TEXT = " ";
        private final JButton renderButton;
        private final JButton editorButton;

        public ButtonColumn() {
            super();
            renderButton = new SGButton(BUTTON_TEXT);
            editorButton = new SGButton(BUTTON_TEXT);
            editorButton.setFocusPainted(false);
            editorButton.setRolloverEnabled(false);
        }

        public Component getTableCellRendererComponent(JTable table,
                Object value, boolean isSelected, boolean hasFocus, int row,
                int column) {
            renderButton.setEnabled(mDataFileArray[row].hasData);
            return renderButton;
        }

        public Component getTableCellEditorComponent(JTable table,
                Object value, boolean isSelected, int row, int column) {
            return editorButton;
        }

        public Object getCellEditorValue() {
            return BUTTON_TEXT;
        }
    }

    /**
     * A cell editor class to display file name.
     */
    private class FileNameColumnCellEditor extends DefaultCellEditor {

        /**
         * SerialVersionUID
         */
        private static final long serialVersionUID = -7226073642075293006L;

        /**
         * Builds the cell editor for a text field.
         *
         * @param textField
         */
        public FileNameColumnCellEditor(JTextField textField) {
            super(textField);
        }

        /**
         * Returns the text field component.
         */
        public Component getTableCellEditorComponent(JTable table,
                Object value, boolean isSelected, int row, int column) {

            // set up new combo box items
            final JTextField textField = (JTextField) super.getTableCellEditorComponent(table,
                    value, isSelected, row, column);
            
            // set the caret position
            if (value != null) {
                String str = value.toString();
                final int len = str.length();
                SwingUtilities.invokeLater(new Runnable(){
                    public void run() {
                        textField.setCaretPosition(len);
                    }
                });
            }

            return textField;
        }
    }

    /**
     * A cell renderer class to display file name.
     */
    private class FileNameColumnCellRenderer extends DefaultTableCellRenderer {

        /**
         * SerialVersionUID
         */
        private static final long serialVersionUID = -1161211373077578663L;

        /**
         * Default constructor.
         *
         */
        public FileNameColumnCellRenderer() {
            super();
        }
        
        /**
         * Returns this component.
         */
        public Component getTableCellRendererComponent(JTable table,
                Object value, boolean isSelected, boolean hasFocus, int row,
                int column) {
            
            // set value
            if (value != null) {
                String path = SGUtility.getFileName(value.toString());
                this.setValue(path);
            }
            
            // set color
            Color bgColor;
            Color fgColor;
            if (isSelected) {
                bgColor = table.getSelectionBackground();
                fgColor = table.getSelectionForeground();
            } else {
                bgColor = table.getBackground();
                fgColor = table.getForeground();
            }
            this.setBackground(bgColor);
            this.setForeground(fgColor);
            
            return this;
        }
    }
    
    private class PropertySingleDataFileChooserDialog extends SGSingleDataFileChooserWizardDialog {
        private static final long serialVersionUID = -224248041535744923L;
        
        PropertySingleDataFileChooserDialog(java.awt.Frame parent, boolean modal) {
            super(parent, modal);
            this.initProperty();
        }
        void initProperty() {
            this.getOKButton().setVisible(true);
        }
        @Override
        public void checkNetCDFURLTextField() {
            this.onOK();
        }
        @Override
        protected void acceptFile(final boolean b) {
            // enable the next button
            this.getOKButton().setEnabled(b);
        }
        @Override
        public void acceptNetCDFUrl(final boolean accpet) {
            this.acceptFile(accpet);
        }
    }

    /**
     * Called when the table is clicked by the mouse button.
     * 
     * @param e
     *            the mouse event
     */
    public void mouseClicked(MouseEvent e) {
        Point p = e.getPoint();
        final int colIndexButton = this.getButtonColumnIndex();
        final int colIndexFileName = this.getFileNameColumnIndex();
        final int colIndex = this.mTable.columnAtPoint(p);
        
        // find the clicked row
        final int rowIndex = this.mTable.rowAtPoint(p);
        
        // when the button is clicked
        if (colIndex == colIndexButton) {
            
            this.mCurDataSetupRowIndex = rowIndex;

            // if the current row has no data, do nothing and return
            if (this.mDataFileArray[rowIndex].hasData == false) {
                return;
            }

            // selected data file object
            DataFile dataFile = mDataFileArray[rowIndex];
            String fileName = dataFile.fileName;
            String dataType = dataFile.dataType;
//            final int figureId = dataFile.figureId;
            
            // create a dialog
            this.createPropertyFileDataDialog(dataType);
            
            if (this.mSingleDataFileChooserWizardDilaog==null) {
                this.mSingleDataFileChooserWizardDilaog =
                    new PropertySingleDataFileChooserDialog(this.getOwnerWindow(), true);
                this.mSingleDataFileChooserWizardDilaog.setPrevious(null);
                this.mSingleDataFileChooserWizardDilaog.setNext(null);
            }
            this.mSingleDataFileChooserWizardDilaog.setVisibleUrlOfNetCDF(
            		SGDataUtility.isNetCDFData(dataType));
            this.mSingleDataFileChooserWizardDilaog.addActionListener(this);
            
            if (null==fileName || fileName.equals("")) {
                String path = this.getCurrentFileDirectory();
                this.mSingleDataFileChooserWizardDilaog.setCurrentFile(path, fileName);
            } else {
                File f = new File(fileName);
                if (f.exists()) {
                    this.mSingleDataFileChooserWizardDilaog.setSelectedFile(f);
                    this.mSingleDataFileChooserWizardDilaog.setFileName(fileName);
                } else {
                    String path = this.getCurrentFileDirectory();
                    this.mSingleDataFileChooserWizardDilaog.setCurrentFile(path, fileName);
                    this.mSingleDataFileChooserWizardDilaog.setFileName(fileName);
                }
            }
            this.mSingleDataFileChooserWizardDilaog.pack();
            
            this.mSingleDataFileChooserWizardDilaog.setLocation(this.getX() + 20, this.getY() + 20);
            this.mSingleDataFileChooserWizardDilaog.setVisible(true);
            
        } else if (colIndex == colIndexFileName) {
        	this.mFocusedRowIndex = rowIndex;
        }
    }
    
    String getCurrentFileDirectory() {
        Preferences pref = Preferences.userNodeForPackage(this.getClass());
        String currentDir = pref.get(SGIPreferencesConstants.PREF_KEY_CURRENT_DIRECTORY, null);

        boolean b = false;
        if (currentDir == null) {
            b = true;
        } else {
            File f = new File(currentDir);
            if (f.exists() == false) {
                b = true;
            }
        }

        if (b) {
            StringBuffer sb = new StringBuffer();
            sb.append(USER_HOME);
            if (SGUtility.identifyOS(OS_NAME_WINDOWS)) {
                sb.append(FILE_SEPARATOR);
                sb.append(MY_DOCUMENTS);
            }
            String path = sb.toString();
            currentDir = path;
        }

        return currentDir;
    }
    
    private void createPropertyFileDataDialog(final String dataType) {
        if (SGDataUtility.isSDArrayData(dataType)) {
            this.mPropertyFileDataDialog = new SGPropertyFileSDArrayDataDialog(this, true);
        } else if (SGDataUtility.isNetCDFData(dataType)) {
            this.mPropertyFileDataDialog = new SGPropertyFileNetCDFDataDialog(this, true);
        } else if (SGDataUtility.isMDArrayData(dataType)) {
            this.mPropertyFileDataDialog = new SGPropertyFileMDArrayDataDialog(this, true);
        }

        // add an action listener
        this.mPropertyFileDataDialog.addActionListener(this);
        
    }
    
    private boolean showPropertyFileDataDialog(
            final String fileName, final String dataType,
            final SGDataColumnInfoSet dataColumnInfoSet, final Map<String, Object> infoMap) {
        
        if (fileName != null && !"".equals(fileName)) {
            // if a text string for file name is given
            
            if (this.setPropertyFileDataDialog(
                    fileName, dataType, dataColumnInfoSet, infoMap)==false) {
                return false;
            }
        } else {
            // clear the dialog
            this.mPropertyFileDataDialog.clear();
            
            // set the data type
            this.mPropertyFileDataDialog.setDataType(dataType, infoMap);
        }

        // show the dialog
        this.mPropertyFileDataDialog.setPrevious(this.mSingleDataFileChooserWizardDilaog);
        this.mPropertyFileDataDialog.pack();
        this.mPropertyFileDataDialog.setLocation(this.getX() + 20, this.getY() + 20);
        this.mPropertyFileDataDialog.setVisible(true);
        
        return true;
    }
    
    private boolean setPropertyFileDataDialog(
            final String fileName, final String dataType,
            final SGDataColumnInfoSet dataColumnInfoSet, final Map<String, Object> infoMap) {

        NetcdfFile ncFile = null;
        IHDF5Reader hdf5Reader = null;
        MatFileReader matReader = null;
        try {
            if (dataColumnInfoSet != null) {
                if (SGDataUtility.isSDArrayData(dataType)) {
                    SGPropertyFileSDArrayDataDialog dg = (SGPropertyFileSDArrayDataDialog) this.mPropertyFileDataDialog;
                    SGSDArrayFile sdFile;
					try {
						sdFile = (SGSDArrayFile) SGApplicationUtility.createDataSource(fileName, 
								dataColumnInfoSet, infoMap);
					} catch (FileNotFoundException e) {
						return false;
					}
                    if (dg.setData(fileName, sdFile, dataType, dataColumnInfoSet,
                            infoMap, false, this.mVersionNumber) == false) {
                        return false;
                    }
                } else if (SGDataUtility.isNetCDFData(dataType)) {
                    SGPropertyFileNetCDFDataDialog dg = (SGPropertyFileNetCDFDataDialog) this.mPropertyFileDataDialog;
                    try {
                        ncFile = SGApplicationUtility.openNetCDF(fileName);
                    } catch (Exception e1) {
                        SGUtility.showMessageDialog(this,
                                "Failed to open NetCDF file.",
                                SGIConstants.TITLE_ERROR,
                                JOptionPane.WARNING_MESSAGE);
                        return false;
                    }
                    if (dg.setData(fileName, new SGNetCDFFile(ncFile),
                            dataType, dataColumnInfoSet,
                            infoMap, false) == false) {
                        return false;
                    }
                } else if (SGDataUtility.isMDArrayData(dataType)) {
                    SGPropertyFileMDArrayDataDialog dg = (SGPropertyFileMDArrayDataDialog) this.mPropertyFileDataDialog;
                    hdf5Reader = SGApplicationUtility.openHDF5(fileName);
                    SGMDArrayFile mdFile = null;
                    FILE_TYPE type = SGApplicationUtility.identifyDataFileType(fileName);
                    if (FILE_TYPE.HDF5_DATA.equals(type)) {
                    	hdf5Reader = SGApplicationUtility.openHDF5(fileName);
                    	mdFile = new SGHDF5File(hdf5Reader);
                    } else if (FILE_TYPE.MATLAB_DATA.equals(type)) {
                    	try {
							matReader = SGApplicationUtility.openMAT(fileName);
						} catch (IOException e) {
							return false;
						}
						mdFile = new SGMATLABFile(fileName, matReader);
                    } else {
                    	return false;
                    }
                    if (dg.setData(fileName, mdFile, dataType, dataColumnInfoSet,
                            infoMap, false) == false) {
                        return false;
                    }
                }
                
            } else {
            	
                if (SGDataUtility.isSDArrayData(dataType)) {
                    FileColumn[] colInfo = null;
                    int length = -1;
                    boolean valid = true;
                    // parse the data file
                    try {
                    	SDArrayFileParseResult result = mDataCreator.parseFileComlumnType(
                    			fileName, dataType, true, this.mVersionNumber);
                    	if (result == null) {
                    		return false;
                    	}
                    	colInfo = result.fileColumns;
                    	length = result.length;
                        if (colInfo == null) {
                            valid = false;
                            showFileOpenErrorMessage();
                            return false;
                        }
                    } catch (FileNotFoundException e1) {
                        valid = false;
                        SGUtility.showMessageDialog(this,
                                "Data file is not found.",
                                SGIConstants.TITLE_ERROR,
                                JOptionPane.WARNING_MESSAGE);
                        return false;
                    }
                    
                    if (valid) {
                        SGDataColumnInfoSet colInfoSet = SGApplicationUtility.getSDArrayDataColInfoSet(
                        		colInfo, length, dataType, infoMap);
                        String dataTypeNew = SGApplicationUtility.getArrayDataType(dataType);
						SGPropertyFileSDArrayDataDialog dg = (SGPropertyFileSDArrayDataDialog) this.mPropertyFileDataDialog;
                        SGSDArrayFile sdFile;
						try {
							sdFile = (SGSDArrayFile) SGApplicationUtility.createDataSource(
									fileName, colInfoSet, infoMap);
						} catch (FileNotFoundException e) {
							return false;
						}
                        if (dg.setData(
                                fileName, sdFile, dataTypeNew, colInfoSet,
                                infoMap, true, this.mVersionNumber) == false) {
                            return false;
                        }
                    }
                    
                } else if (SGDataUtility.isNetCDFData(dataType)) {
                	
                    boolean valid = true;
                    try {
                        ncFile = SGApplicationUtility.openNetCDF(fileName);
                    } catch (Exception e1) {
                        valid = false;
                        showFileOpenErrorMessage();
                        return false;
                    }                  
                    
                    if (valid) {
                        SGNetCDFFile nc = new SGNetCDFFile(ncFile);
                        List<SGNetCDFVariable> varList = nc.getVariables();
                        SGDataColumnInfo[] infoArray = SGDataUtility.getNetCDFDataColumnInfo(varList, infoMap);
                        SGDataColumnInfoSet colInfoSet = new SGDataColumnInfoSet(infoArray);
                        SGPropertyFileNetCDFDataDialog dg = (SGPropertyFileNetCDFDataDialog) this.mPropertyFileDataDialog;
                        if (dg.setData(
                                fileName, nc, 
                                dataType, colInfoSet, infoMap, true) == false) {
                            return false;
                        }
                    }
                    
                } else if (SGDataUtility.isMDArrayData(dataType)) {
                    
                    boolean valid = true;
	                if (SGDataUtility.isHDF5FileData(dataType)) {
	                	try {
	                    	hdf5Reader = SGApplicationUtility.openHDF5(fileName);
	                	} catch (Exception e) {
	                		valid = false;
	                        showFileOpenErrorMessage();
	                		return false;
	                	}
	                } else if (SGDataUtility.isMATLABData(dataType)) {
	                	try {
	                    	matReader = SGApplicationUtility.openMAT(fileName);
	                	} catch (Exception e) {
	                		valid = false;
	                        showFileOpenErrorMessage();
	                		return false;
	                	}
	                }
	                
	                if (valid) {
                    	SGMDArrayFile mdFile = null;
                    	if (hdf5Reader != null) {
                    		mdFile = new SGHDF5File(hdf5Reader);
                    	} else if (matReader != null) {
                    		mdFile = new SGMATLABFile(fileName, matReader);
                    	} else {
                    		return false;
                    	}
                    	SGMDArrayVariable[] vars = mdFile.getVariables();
                        SGDataColumnInfo[] infoArray = SGDataUtility.getMDArrayDataColumnInfo(mdFile, vars, infoMap);
                        if (infoArray == null) {
                        	return false;
                        }
                        SGDataColumnInfoSet colInfoSet = new SGDataColumnInfoSet(infoArray);
                        SGPropertyFileMDArrayDataDialog dg = (SGPropertyFileMDArrayDataDialog) this.mPropertyFileDataDialog;
                        if (dg.setData(
                                fileName, mdFile, 
                                dataType, colInfoSet, infoMap, true) == false) {
                            return false;
                        }
	                }
                    
                } else {
                    // clear the dialog
                    this.mPropertyFileDataDialog.clear();

                    // set the data type
                    this.mPropertyFileDataDialog.setDataType(dataType, infoMap);

                    if (null!=fileName) {
                        this.mPropertyFileDataDialog.setFileName(fileName);
                    }
                }
            }
            
        } finally {
            if (ncFile != null) {
                try {
                    ncFile.close();
                } catch (IOException e1) {
                }
            }
            if (hdf5Reader != null) {
            	hdf5Reader.close();
            }
        }
        
        return true;
    }
    
    private void showFileOpenErrorMessage() {
        SGUtility.showMessageDialog(this, 
        		SGIApplicationTextConstants.MSG_DATA_FILE_OPEN_FAILURE,
                SGIConstants.TITLE_ERROR, 
                JOptionPane.WARNING_MESSAGE);
    }

    public void mouseEntered(MouseEvent e) {
    }

    public void mouseExited(MouseEvent e) {
    }

    public void mousePressed(MouseEvent e) {
    }

    public void mouseReleased(MouseEvent e) {
    }

    /**
     * Returns the selected file path.
     * 
     * @return the selected file path
     */
    public String getSelectedFilepath() {
        if (this.mPropertyFileDataDialog != null) {
            return this.mPropertyFileDataDialog.getFileName();
        } else {
            return null;
        }
    }

    /**
     * Sets the file path and returns a file.
     * 
     * @param dir
     *             directory name
     * @param name
     *             file name
     * @return
     *             a file object
     */
    public void setSelectedFile(String dir, String name) {
        if (this.mPropertyFileDataDialog != null) {
            this.mPropertyFileDataDialog.setCurrentFile(dir, name);
        }
    }
    
    long lastUsed() {
        if (this.mPropertyFileDataDialog != null) {
            return this.mPropertyFileDataDialog.lastUsed();
        } else {
            return 0L;
        }
    }

    @Override
    public void editingStopped(ChangeEvent e) {
        Object source = e.getSource();
        if (source instanceof DefaultCellEditor) {
            if (this.mFocusedRowIndex == -1) {
                return;
            }
            DefaultCellEditor editor = (DefaultCellEditor) source;
            String text = (String) editor.getCellEditorValue();
            if (SGNetCDFDataFileChooserPanel.isNetcdfUrl(text) == false) {
                File f = new File(text);
                this.setSelectedFile(this.mFocusedRowIndex, f.getPath());
            } else {
                this.setSelectedFile(this.mFocusedRowIndex, text);
            }
            this.updateAvailableButtons();
        }
    }

    @Override
    public void editingCanceled(ChangeEvent e) {
        Object source = e.getSource();
        if (source instanceof DefaultCellEditor) {
            this.mFocusedRowIndex = -1;
        }
    }

    private SGTable createTableInstance() {
        return new SGTable() {
			private static final long serialVersionUID = 8123021601129253077L;
			
			@Override
			public String getToolTipText(MouseEvent e) {
                final int colIndex = columnAtPoint(e.getPoint());
				if (colIndex == 4) {
					return null;
				}
				return super.getToolTipText(e);
            }
        };
    }

}
