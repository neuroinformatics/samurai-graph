package jp.riken.brain.ni.samuraigraph.data;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.BoundedRangeModel;
import javax.swing.DefaultBoundedRangeModel;
import javax.swing.ImageIcon;
import javax.swing.JSlider;
import javax.swing.Timer;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import jp.riken.brain.ni.samuraigraph.base.SGButton;
import jp.riken.brain.ni.samuraigraph.base.SGUtility;

/**
 * A panel with a slider.
 *
 */
public class SGSliderPanel extends javax.swing.JPanel implements ActionListener,
		ChangeListener, MouseListener {

	private static final long serialVersionUID = 6493143211756709297L;

    /**
     * A timer.
     */
    protected Timer mTimer;

    private SGButton mPressedButton = null;

	/** Creates new form SGSliderPanel */
    public SGSliderPanel() {
    	super();
        initComponents();
        this.initProperty();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mSlider = new javax.swing.JSlider();
        mLabelPanel = new javax.swing.JPanel();
        mLeftButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();
        mRightButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();
        mMaxLabel = new javax.swing.JLabel();
        mMinLabel = new javax.swing.JLabel();
        mCurIndexLabel = new javax.swing.JLabel();

        setLayout(new java.awt.GridBagLayout());

        mSlider.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 2);
        add(mSlider, gridBagConstraints);

        mLabelPanel.setLayout(new java.awt.GridBagLayout());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTH;
        add(mLabelPanel, gridBagConstraints);

        mLeftButton.setPreferredSize(new java.awt.Dimension(18, 18));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        add(mLeftButton, gridBagConstraints);

        mRightButton.setPreferredSize(new java.awt.Dimension(18, 18));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        add(mRightButton, gridBagConstraints);

        mMaxLabel.setFont(new java.awt.Font("Dialog", 0, 10));
        mMaxLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        mMaxLabel.setText("max");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        add(mMaxLabel, gridBagConstraints);

        mMinLabel.setFont(new java.awt.Font("Dialog", 0, 10));
        mMinLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        mMinLabel.setText("min");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        add(mMinLabel, gridBagConstraints);

        mCurIndexLabel.setFont(new java.awt.Font("Dialog", 0, 10));
        mCurIndexLabel.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        mCurIndexLabel.setText("index");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        add(mCurIndexLabel, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel mCurIndexLabel;
    private javax.swing.JPanel mLabelPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mLeftButton;
    private javax.swing.JLabel mMaxLabel;
    private javax.swing.JLabel mMinLabel;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mRightButton;
    private javax.swing.JSlider mSlider;
    // End of variables declaration//GEN-END:variables

    /**
     * The list of listeners for the change of slider.
     */
    private List<SGSliderPanel.ISliderChangeListener> mSliderListenerList
    		= new ArrayList<SGSliderPanel.ISliderChangeListener>();

    private int[] mAvailableIndexArray = new int[0];

    // Initializes the properties.
    private void initProperty() {
        // add event listener
        this.mLeftButton.addActionListener(this);
        this.mRightButton.addActionListener(this);
        this.mSlider.addChangeListener(this);
        this.mSlider.addMouseListener(this);
        this.mLeftButton.addMouseListener(this);
        this.mRightButton.addMouseListener(this);

        // setup the slider model
        BoundedRangeModel model = new DefaultBoundedRangeModel();
        this.mSlider.setModel(model);

        // create icons
        this.mLeftButton.setIcon(this.createIcon("Minus.png"));
        this.mRightButton.setIcon(this.createIcon("Plus.png"));
        this.mLeftButton.setDisabledIcon(this.createIcon("MinusDisabled.png"));
        this.mRightButton.setDisabledIcon(this.createIcon("PlusDisabled.png"));

		// initializes the timer
		this.mTimer = new Timer(100, this);
		this.mTimer.setInitialDelay(300);
    }

    private ImageIcon createIcon(final String name) {
    	return SGUtility.createIcon(this, name);
    }

    /**
     * Sets the components enabled.
     *
     * @param enabled
     *           true to enable
     */
    public void setComponentsEnabled(final boolean enabled) {
        this.mSlider.setEnabled(enabled);
        this.mLeftButton.setEnabled(enabled);
        this.mRightButton.setEnabled(enabled);
        this.mMinLabel.setEnabled(enabled);
        this.mMaxLabel.setEnabled(enabled);
        this.mCurIndexLabel.setEnabled(enabled);
    }

    /**
     * Called when an action event is invoked.
     *
     * @param e
     *          an action event
     */
	@Override
    public void actionPerformed(ActionEvent e) {
        Object source = e.getSource();
        if (source.equals(this.mLeftButton)) {
            this.mSlider.setValue(this.mSlider.getValue() - 1);
        } else if (source.equals(this.mRightButton)) {
            this.mSlider.setValue(this.mSlider.getValue() + 1);
        } else if (source.equals(this.mTimer)) {
        	final int cur = this.mSlider.getValue();
        	int value = cur;
			if (this.mLeftButton.equals(this.mPressedButton)) {
				value--;
			} else if (this.mRightButton.equals(this.mPressedButton)) {
				value++;
			}
			if (value != cur) {
				final int min = this.mSlider.getMinimum();
				final int max = this.mSlider.getMaximum();
//				final int valueRange = max - min + 1;
				if (value < min) {
//					value += valueRange;
					value = min;
				} else if (value > max) {
//					value -= valueRange;
					value = max;
				}
				this.mSlider.setValue(value);
			}
		}
    }

    /**
     * Returns the current index.
     *
     * @return the current index
     */
    public int getCurrentIndex() {
        return this.mSlider.getValue();
    }

    /**
     * Adds a listener for the change of slider.
     *
     * @param l
     *          a listener
     */
    public void addSliderChangeListener(SGSliderPanel.ISliderChangeListener l) {
    	this.mSliderListenerList.add(l);
    }

    /**
     * Called when the slider moves.
     */
    public void stateChanged(ChangeEvent e) {
        Object source = e.getSource();
        if (source.equals(this.mSlider)) {
            final int index = this.getCurrentIndex();

            // updates the current index
            if (this.onCurrentIndexChanged(index)) {
                // notifies to the listeners
                for (SGSliderPanel.ISliderChangeListener l : this.mSliderListenerList) {
                	l.changed(this);
                }
            }
        }
    }

    /**
     * Sets the range.
     *
     * @param min
     *           the minimum value
     * @param max
     *           the maximum value
     * @param cur
     *           the current value
     */
    public void setRange(final int min, final int max, final int cur) {
        // sets the values to the slider model
        BoundedRangeModel model = this.mSlider.getModel();
        model.setMinimum(min);
        model.setMaximum(max);
        model.setExtent(0);
        model.setValue(cur);

        // sets available index list
        this.mAvailableIndexArray = new int[max - min + 1];
        int cnt = 0;
        for (int ii = min; ii <= max; ii++) {
        	this.mAvailableIndexArray[cnt] = ii;
        	cnt++;
        }

        // sets the minimum and maximum values to the labels
        this.mMinLabel.setText(Integer.toString(min));
        this.mMaxLabel.setText(Integer.toString(max));

        // updates the current index
        this.onCurrentIndexChanged(cur);
    }

    private boolean onCurrentIndexChanged(final int index) {
    	if (Arrays.binarySearch(this.mAvailableIndexArray, index) < 0) {
    		return false;
    	}

    	// updates the text for the current value
        this.mCurIndexLabel.setText(Integer.toString(index));

        // updates the tooltip text
        BoundedRangeModel model = this.mSlider.getModel();
        final int len = model.getMaximum() - model.getMinimum();
        StringBuffer sb = new StringBuffer();
        sb.append(index);
        sb.append('/');
        sb.append(len);
        final String text = sb.toString();
        this.mSlider.setToolTipText(text);
        this.mLeftButton.setToolTipText(text);
        this.mRightButton.setToolTipText(text);

        return true;
    }

    /**
	 * An interface for the listener for the change of the slider.
	 *
	 */
	public static interface ISliderChangeListener {
		/**
		 * Invoked when the value of the slider is changed.
		 *
		 * @param p
		 *          a dimension panel that has the slider
		 */
		public void changed(SGSliderPanel p);
	}

	void setSliderPreferredWidth(final int width) {
		Dimension cur = this.mSlider.getPreferredSize();
		this.mSlider.setPreferredSize(new Dimension(width, cur.height));
	}

	/**
	 * Returns the slider.
	 *
	 * @return the slider
	 */
	public JSlider getSlider() {
		return this.mSlider;
	}

	/**
	 * Sets the visibility of step buttons.
	 *
	 * @param b
	 *          true to set visible
	 */
	public void setStepButtonVisible(final boolean b) {
		this.mLeftButton.setVisible(b);
		this.mRightButton.setVisible(b);
	}

	/**
	 * Sets available indices.
	 *
	 * @param indices
	 *           the array of available indices
	 */
	public void setAvailableIndices(int[] indices) {
		this.mAvailableIndexArray = indices.clone();
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}

	@Override
	public void mousePressed(MouseEvent e) {
        Object source = e.getSource();
        if (source.equals(this.mLeftButton) || source.equals(this.mRightButton)) {
        	this.mPressedButton = (SGButton) source;
        	this.mTimer.stop();
        	this.mTimer.start();
        }
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mSlider)) {
			final int curIndex = this.getCurrentIndex();
			final int minDiffIndex = SGUtility.findNearestValue(curIndex, this.mAvailableIndexArray);
			if (minDiffIndex != -1) {
				this.mSlider.setValue(minDiffIndex);
			}
        } else if (source.equals(this.mLeftButton) || source.equals(this.mRightButton)) {
        	this.mTimer.stop();
        	this.mPressedButton = null;
        }
	}

	@Override
	public void mouseEntered(MouseEvent e) {
	}

	@Override
	public void mouseExited(MouseEvent e) {
	}
}
