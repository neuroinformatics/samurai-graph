package jp.riken.brain.ni.samuraigraph.data;

import java.awt.Color;
import java.awt.Component;
import java.util.Arrays;
import java.util.List;

import javax.swing.JTable;
import javax.swing.SwingUtilities;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import javax.swing.text.JTextComponent;

import jp.riken.brain.ni.samuraigraph.base.SGAttribute;
import jp.riken.brain.ni.samuraigraph.base.SGTableSelectionPanel;

/**
 * A panel to display the attributes.
 *
 */
public class SGAttributePanel extends SGTableSelectionPanel {

    private static final long serialVersionUID = 8246986947494258210L;

    /** Creates new form SGAttributePanel */
    public SGAttributePanel() {
        super();
        initComponents();
        this.initProperty();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mTableScrollPane = new javax.swing.JScrollPane();
        mTable = new jp.riken.brain.ni.samuraigraph.base.SGTable();
        mNameTextField = new jp.riken.brain.ni.samuraigraph.base.SGTextField();
        mTextAreaScrollPane = new javax.swing.JScrollPane();
        mTextArea = new javax.swing.JTextArea();

        setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.Y_AXIS));

        mTableScrollPane.setPreferredSize(new java.awt.Dimension(452, 120));

        mTable.setFont(new java.awt.Font("Dialog", 0, 11));
        mTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        mTableScrollPane.setViewportView(mTable);

        add(mTableScrollPane);

        mNameTextField.setColumns(3);
        mNameTextField.setEditable(false);
        mNameTextField.setFont(new java.awt.Font("Dialog", 0, 12));
        add(mNameTextField);

        mTextArea.setBackground(new java.awt.Color(240, 240, 240));
        mTextArea.setColumns(20);
        mTextArea.setEditable(false);
        mTextArea.setFont(new java.awt.Font("Dialog", 0, 12));
        mTextArea.setRows(5);
        mTextAreaScrollPane.setViewportView(mTextArea);

        add(mTextAreaScrollPane);
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    protected jp.riken.brain.ni.samuraigraph.base.SGTextField mNameTextField;
    protected jp.riken.brain.ni.samuraigraph.base.SGTable mTable;
    private javax.swing.JScrollPane mTableScrollPane;
    protected javax.swing.JTextArea mTextArea;
    private javax.swing.JScrollPane mTextAreaScrollPane;
    // End of variables declaration//GEN-END:variables

    /**
     * Name of the column for the sequential number.
     */
    public static final String COLUMN_NAME_NUMBER = "No.";

    /**
     * Name of the column for the name of each attribute.
     */
    public static final String COLUMN_NAME_NAME = "Name";

    /**
     * Name of the column for the value of each attribute.
     */
    public static final String COLUMN_NAME_VALUE = "Value";

    /**
     * The array of column name.
     */
    public static final String[] COLUMN_NAME_ARRAY = { COLUMN_NAME_NUMBER,
        COLUMN_NAME_NAME, COLUMN_NAME_VALUE };

    /**
     * A constant array of column width.
     */
    private static final int[] PREFERRED_COLUMN_WIDTH_ARRAY = { 10, 60, 180 };

	private void initProperty() {
    	this.mTable.addMouseListener(this);
		this.mTextArea.setLineWrap(true);
		
        // initialize the table model
        this.initTableModel();
        
        // update the table
        this.updateTable();
	}

	@Override
	protected void initTableModel() {
		super.initTableModel();
        final int timeColIndex = this.getColumnIndex(COLUMN_NAME_VALUE);
        TableColumn timeCol = this.mTable.getColumnModel().getColumn(timeColIndex);
        timeCol.setCellRenderer(new AttributeValueColumnCellRenderer());
	}
	
    public int getColumnIndex(final String identifier) {
        return this.mTable.getColumnModel().getColumnIndex(identifier);
    }

    protected String[] getColumnNameArray() {
        return COLUMN_NAME_ARRAY;
    }
    
    protected int[] getPreferredColumnWidthArray() {
        return PREFERRED_COLUMN_WIDTH_ARRAY;
    }

    /**
     * Sets the attributes.
     * 
     * @param aList
     *          the list of attributes
     */
    public void setAttributes(List<SGAttribute> aList) {
        this.initTableModel();
        AttributeTableModel model = (AttributeTableModel) this.mTableModel;
        for (int ii = 0; ii < aList.size(); ii++) {
            SGAttribute attr = aList.get(ii);
            model.addRow(ii, attr);
        }
        this.updateTable();

        if (aList.size() == 0) {
        	this.mTextArea.setText("");
        } else {
            SwingUtilities.invokeLater(new Runnable() {
            	public void run() {
                    // selects the first row
                    mTable.setRowSelectionInterval(0, 0);
                    
                    // updates the text area
                	updateTextArea();
            	}
            });
        }
    }

    /**
     * Returns a text string about selected row.
     *
     * @param row
     *          the row index
     * @return
     *          a text string about selected row
     */
    public String getRowText(final int row) {
        TableColumnModel model = this.mTable.getColumnModel();
        final int colIndexValue =  model.getColumnIndex(COLUMN_NAME_VALUE);
        Object value = this.mTable.getValueAt(row, colIndexValue);
        StringBuffer sb = new StringBuffer();
        if (value != null) {
            sb.append(value);
        }
        return sb.toString();
    }

    /**
     * Returns the name of selected row.
     *
     * @param row
     *          the row index
     * @return
     *          the name of selected row
     */
    public String getRowName(final int row) {
        TableColumnModel model = this.mTable.getColumnModel();
        final int colIndexName =  model.getColumnIndex(COLUMN_NAME_NAME);
        Object name = this.mTable.getValueAt(row, colIndexName);
        if (name == null) {
        	return "";
        } else {
            return name.toString();
        }
    }

    /**
     * A table model class for attributes table.
     *
     */
    protected static class AttributeTableModel extends SelectionTableModel {

        private static final long serialVersionUID = -6469371272912213709L;
        
        /**
         * The default constructor.
         *
         */
        protected AttributeTableModel() {
            super();
        }

        /**
         * Add a data.
         * 
         * @param index
         *           the array index
         * @param attr
         *           the attribute to add
         */
        protected void addRow(final int index, SGAttribute attr) {
        	final int size = attr.getSize();
        	final Object value;
        	if (size == 0) {
        		value = null;
        	} else {
            	StringBuffer sb = new StringBuffer();
            	for (int ii = 0; ii < size; ii++) {
            		Object obj = attr.getValue(ii);
            		if (obj == null) {
            			continue;
            		}
            		if (ii > 0) {
            			sb.append(", ");
            		}
            		String str = null;
            		if (obj instanceof int[]) {
            			str = Arrays.toString((int[]) obj);
            		} else if (obj instanceof float[]) {
            			str = Arrays.toString((float[]) obj);
            		} else if (obj instanceof double[]) {
            			str = Arrays.toString((double[]) obj);
            		} else if (obj instanceof char[]) {
            			str = Arrays.toString((char[]) obj);
            		} else if (obj instanceof short[]) {
            			str = Arrays.toString((short[]) obj);
            		} else if (obj instanceof long[]) {
            			str = Arrays.toString((long[]) obj);
            		} else if (obj instanceof byte[]) {
            			str = Arrays.toString((byte[]) obj);
            		} else if (obj instanceof boolean[]) {
            			str = Arrays.toString((boolean[]) obj);
            		} else if (obj instanceof String[]) {
            			str = Arrays.toString((String[]) obj);
            		} else if (obj instanceof Object[]) {
            			str = Arrays.toString((Object[]) obj);
            		}
            		if (str != null) {
            			if (str.startsWith("[") && str.endsWith("]")) {
            				str = str.substring(1, str.length() - 1);
            			}
            		}
            		if (str == null) {
            			str = obj.toString();
            		}
            		sb.append(str);
            	}
            	value = sb.toString();
        	}
            Object[] array = { Integer.toString(index + 1), attr.getName(),
                    value };
            super.addRow(array);
        }
    }

	@Override
	protected void updateTextArea() {
        // get the values at pressed row and set them to the text area
        final int row = this.mTable.getSelectedRow();
        String name = this.getRowName(row);
        this.mNameTextField.setText(name);
        String text = this.getRowText(row);
        this.mTextArea.setText(text);
	}

	@Override
	protected SelectionTableModel createTableModelInstance() {
		return new AttributeTableModel();
	}

	@Override
    protected JTable getTable() {
    	return this.mTable;
    }
    
	@Override
    protected JTextComponent getTextComponent() {
		return this.mTextArea;
	}

    protected class AttributeValueColumnCellRenderer extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -6238379300541390902L;
		
		public AttributeValueColumnCellRenderer() {
            super();
        }

        @Override
        public Component getTableCellRendererComponent(JTable table,
                Object value, boolean isSelected, boolean hasFocus, int row,
                int column) {
            Component com = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
        	final String str;
        	if (value != null) {
        		str = value.toString();
        		Color cl = isSelected ? Color.WHITE : Color.BLACK;
				this.setForeground(cl);
        	} else {
        		str = "<< Failed to read the value. >>";
				this.setForeground(Color.RED);
        	}
        	this.setText(str);
        	return com;
        }
    }

}
