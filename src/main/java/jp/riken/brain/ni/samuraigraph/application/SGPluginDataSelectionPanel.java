package jp.riken.brain.ni.samuraigraph.application;

import java.awt.Color;
import java.awt.Component;
import java.awt.Point;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.swing.AbstractCellEditor;
import javax.swing.Icon;
import javax.swing.JCheckBox;
import javax.swing.JTable;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.event.MouseInputListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumn;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeCellEditor;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;

import jp.riken.brain.ni.samuraigraph.base.SGData;
import jp.riken.brain.ni.samuraigraph.base.SGDataBuffer;
import jp.riken.brain.ni.samuraigraph.base.SGDataBufferPolicy;
import jp.riken.brain.ni.samuraigraph.base.SGUtility;
import jp.riken.brain.ni.samuraigraph.data.SGDataTypeConstants;
import jp.riken.brain.ni.samuraigraph.data.SGDataUtility;
import jp.riken.brain.ni.samuraigraph.data.SGISXYTypeMultipleData;
import jp.riken.brain.ni.samuraigraph.data.SGISXYTypeSingleData;
import jp.riken.brain.ni.samuraigraph.data.SGSXYDataBuffer;
import jp.riken.brain.ni.samuraigraph.data.SGSXYDataBufferPolicy;
import jp.riken.brain.ni.samuraigraph.data.SGSXYMultipleDataBuffer;

/**
 * The panel to select data for the input/output of the plug-in.
 *
 */
public class SGPluginDataSelectionPanel extends javax.swing.JPanel implements MouseInputListener {

	private static final long serialVersionUID = 7511692215485257640L;

	/** Creates new form SGPluginDataSelectionPanel */
    public SGPluginDataSelectionPanel() {
    	super();
        initComponents();
        this.initProperty();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mDataTableScrollPane = new javax.swing.JScrollPane();
        mDataTable = new jp.riken.brain.ni.samuraigraph.base.SGTable();
        mDataTreeScrollPane = new javax.swing.JScrollPane();
        mDataTree = new javax.swing.JTree();

        setLayout(new java.awt.GridBagLayout());

        mDataTableScrollPane.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
        mDataTableScrollPane.setFont(new java.awt.Font("Dialog", 0, 11));
        mDataTableScrollPane.setPreferredSize(new java.awt.Dimension(273, 120));

        mDataTable.setFont(new java.awt.Font("Dialog", 0, 11)); // NOI18N
        mDataTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        mDataTableScrollPane.setViewportView(mDataTable);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(0, 2, 0, 0);
        add(mDataTableScrollPane, gridBagConstraints);

        mDataTreeScrollPane.setPreferredSize(new java.awt.Dimension(273, 120));

        mDataTree.setFont(new java.awt.Font("Dialog", 0, 12));
        mDataTreeScrollPane.setViewportView(mDataTree);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 2);
        add(mDataTreeScrollPane, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    protected jp.riken.brain.ni.samuraigraph.base.SGTable mDataTable;
    private javax.swing.JScrollPane mDataTableScrollPane;
    private javax.swing.JTree mDataTree;
    private javax.swing.JScrollPane mDataTreeScrollPane;
    // End of variables declaration//GEN-END:variables

    /**
     * Name of the column for the sequential number.
     */
    public static final String COLUMN_NAME_NUMBER = "  ";

    /**
     * Name of the column for the name of parameters.
     */
    public static final String COLUMN_NAME_NAME = "Name";

    /**
     * Name of the column for data type.
     */
    public static final String COLUMN_NAME_DATA_TYPE = "Type";

	/**
	 * The array of column names for data.
	 */
	public static final String[] DATA_COLUMN_NAME_ARRAY = { COLUMN_NAME_NUMBER, 
			COLUMN_NAME_NAME, COLUMN_NAME_DATA_TYPE };

	// The array of column width.
	private static final int[] DATA_PREFERRED_COLUMN_WIDTH_ARRAY = { 30, 60, 60 };

	/**
	 * The table model.
	 */
    protected DataTableModel mDataTableModel = null;

    /**
     * The tree model.
     */
    protected DataTreeModel mDataTreeModel = null;

	private void initProperty() {
		// setup the table for data
        this.mDataTableModel = new DataTableModel();
        this.mDataTableModel.setColumnIdentifiers(DATA_COLUMN_NAME_ARRAY);
        this.mDataTable.setModel(this.mDataTableModel);
        TableColumn numberColumn = this.mDataTable.getColumn(COLUMN_NAME_NUMBER);
        numberColumn.setCellRenderer(new NumberCellRenderer());
        numberColumn.setMinWidth(DATA_PREFERRED_COLUMN_WIDTH_ARRAY[0]);
        numberColumn.setMaxWidth(DATA_PREFERRED_COLUMN_WIDTH_ARRAY[0]);
        numberColumn.setResizable(false);
        this.mDataTable.getTableHeader().setReorderingAllowed(false);
        
        this.updateTable();
        
		// setup the tree
        DefaultMutableTreeNode root = new DefaultMutableTreeNode("Data");
        this.mDataTreeModel = new DataTreeModel(root, true);
        this.mDataTree.setModel(this.mDataTreeModel);
        DataTreeCellRenderer renderer = new DataTreeCellRenderer();
        this.mDataTree.setCellRenderer(renderer);
        DataTreeCellEditor editor = new DataTreeCellEditor();
        this.mDataTree.setCellEditor(editor);
        this.mDataTree.setEditable(true);
        
        this.mDataTable.addMouseListener(this);
        this.mDataTable.addMouseMotionListener(this);
	}

    /**
     * Updates the table.
     * 
     */
    public void updateTable() {
    	if (this.mDataTableModel != null) {
            for (int ii = 0; ii < DATA_COLUMN_NAME_ARRAY.length; ii++) {
                TableColumn cl = this.mDataTable.getColumn(DATA_COLUMN_NAME_ARRAY[ii]);
                cl.setPreferredWidth(DATA_PREFERRED_COLUMN_WIDTH_ARRAY[ii]);
            }
    	}
    }

    private TreeNode getSelectedNode() {
		TreePath selectedPath = this.mDataTree.getSelectionPath();
		TreeNode selectedNode = (TreeNode) selectedPath.getLastPathComponent();
		return selectedNode;
    }

    /**
     * Adds a data.
     * 
     * @param name
     *           the name of data
     * @param data
     *           the data object
     */
    public void addData(String name, SGData data) {
    	DefaultMutableTreeNode root = (DefaultMutableTreeNode) this.mDataTreeModel.getRoot();
    	List<String> childNameList = new ArrayList<String>();
    	List<SGData> childDataList = new ArrayList<SGData>();
    	int childNum = 1;
    	if (data instanceof SGISXYTypeMultipleData) {
    		SGISXYTypeMultipleData multipleData = (SGISXYTypeMultipleData) data;
    		SGISXYTypeSingleData[] sxyArray = multipleData.getSXYDataArray();
    		childNum = multipleData.getChildNumber();
    		if (childNum > 1) {
        		for (int ii = 0; ii < childNum; ii++) {
        			StringBuffer sb = new StringBuffer();
        			sb.append('[');
        			sb.append(ii + 1);
        			sb.append("] ");
        			sb.append(name);
        			childNameList.add(sb.toString());
        			childDataList.add((SGData) sxyArray[ii]);
        		}
    		}
    	}
    	final boolean allowsChildren = (childNameList.size() > 1);
    	DataTreeNode node = new DataTreeNode(name, new WrappedData((SGData) data.clone()));
    	node.setSelected(true);
    	node.setAllowsChildren(allowsChildren);
    	root.add(node);
    	if (childNum > 1) {
        	for (int ii = 0; ii < childNum; ii++) {
        		String childName = childNameList.get(ii);
        		SGData childData = childDataList.get(ii);
        		DataTreeNode childNode = new DataTreeNode(childName, new WrappedData(childData));
        		childNode.setSelected(true);
            	childNode.setAllowsChildren(false);
            	node.add(childNode);
        	}
    	}
    	this.mDataTreeModel.reload();
    }
    
    void deleteTreeNode() {
    	DefaultMutableTreeNode root = (DefaultMutableTreeNode) this.mDataTreeModel.getRoot();
    	this.deleteTreeNodeRecursively(root);
    }

    private void deleteTreeNodeRecursively(TreeNode node) {
    	for (int ii = 0; ii < node.getChildCount(); ii++) {
    		TreeNode cNode = node.getChildAt(ii);
    		this.deleteTreeNodeRecursively(cNode);
    	}
    	if (node instanceof DataTreeNode) {
    		DataTreeNode dataNode = (DataTreeNode) node;
        	SGData data = dataNode.getData();
        	if (data != null) {
            	data.dispose();
        	}
    	}
    }

    /**
     * Adds a data buffer.
     * 
     * @param name
     *           the name of data
     * @param buffer
     *           a data buffer
     */
    public void addData(String name, SGDataBuffer buffer) {
    	DefaultMutableTreeNode root = (DefaultMutableTreeNode) this.mDataTreeModel.getRoot();
    	List<String> childNameList = new ArrayList<String>();
    	List<SGDataBuffer> childBufferList = new ArrayList<SGDataBuffer>();
    	int childNum = 1;
    	if (buffer instanceof SGSXYMultipleDataBuffer) {
    		SGSXYMultipleDataBuffer multipleDataBuffer = (SGSXYMultipleDataBuffer) buffer;
    		SGSXYDataBuffer[] childBuffers = multipleDataBuffer.getSXYDataBufferArray();
    		childNum = childBuffers.length;
    		if (childNum > 1) {
        		for (int ii = 0; ii < childNum; ii++) {
        			StringBuffer sb = new StringBuffer();
        			sb.append('[');
        			sb.append(ii + 1);
        			sb.append("] ");
        			sb.append(name);
        			childNameList.add(sb.toString());
        			childBufferList.add(childBuffers[ii]);
        		}
    		}
    	}
    	final boolean allowsChildren = (childNameList.size() > 1);
    	DataTreeNode node = new DataTreeNode(name, new WrappedData(buffer));
    	node.setSelected(true);
    	node.setAllowsChildren(allowsChildren);
    	root.add(node);
    	if (childNum > 1) {
        	for (int ii = 0; ii < childNum; ii++) {
        		String childName = childNameList.get(ii);
        		SGDataBuffer childBuffer = childBufferList.get(ii);
        		DataTreeNode childNode = new DataTreeNode(childName, new WrappedData(childBuffer));
        		childNode.setSelected(true);
            	childNode.setAllowsChildren(false);
            	node.add(childNode);
        	}
    	}
    	this.mDataTreeModel.reload();
    }

    public int getDataColumnIndex(final String identifier) {
        return this.mDataTable.getColumnModel().getColumnIndex(identifier);
    }

    static class DataTableModel extends DefaultTableModel {
        
		private static final long serialVersionUID = 6137995086357112556L;

		public DataTableModel() {
            super();
        }

        protected void addRow(final int index, String name, String dataType) {
            Object[] array = { index + 1, name, dataType };
            super.addRow(array);
        }

        @Override
        public int getColumnCount() {
            return DATA_COLUMN_NAME_ARRAY.length;
        }

        @Override
        public String getColumnName(int index) {
            return DATA_COLUMN_NAME_ARRAY[index];
        }
        
        /**
         * Returns false for the column for column type.
         */
        @Override
        public boolean isCellEditable(int row, int col) {
        	return false;
        }
    }

    static class DataTreeModel extends DefaultTreeModel {

		private static final long serialVersionUID = -470320600103083770L;

		public DataTreeModel(TreeNode root, boolean asksAllowsChildren) {
			super(root, asksAllowsChildren);
		}
    }

	static class DataTreeCellRenderer implements TreeCellRenderer {

		private DefaultTreeCellRenderer rootRenderer = new DefaultTreeCellRenderer();

		private JCheckBox checkBoxRenderer = new JCheckBox();
		
		private boolean neglectItemEvent = false;
		
		private Icon fullySelectedIcon = null;

		private Icon unselectedIcon = null;

		private Icon onlyChildSelectedIcon = null;

		private Icon partiallySelectedIcon = null;

		public DataTreeCellRenderer() {
			super();
			this.unselectedIcon = SGUtility.createIcon(this.checkBoxRenderer, "CheckBoxUnselected.png");
			this.fullySelectedIcon = SGUtility.createIcon(this.checkBoxRenderer, "CheckBoxFullySelected.png");
			this.onlyChildSelectedIcon = SGUtility.createIcon(this.checkBoxRenderer, "CheckBoxOnlyChildSelected.png");
			this.partiallySelectedIcon = SGUtility.createIcon(this.checkBoxRenderer, "CheckBoxPartiallySelected.png");
			this.checkBoxRenderer.setBackground(Color.WHITE);
		}

		protected JCheckBox getCheckBoxRenderer() {
			return this.checkBoxRenderer;
		}

		@Override
		public Component getTreeCellRendererComponent(JTree tree, Object value,
				boolean selected, boolean expanded, boolean leaf, int row,
				boolean hasFocus) {
			
			Component returnValue;
			if (row == 0) {
				// root
				returnValue = rootRenderer.getTreeCellRendererComponent(
						tree, value, selected, expanded, leaf, row, hasFocus);
			} else {
				this.neglectItemEvent = true;
				this.checkBoxRenderer.setSelected(false);
				this.checkBoxRenderer.setEnabled(tree.isEnabled());
				if (value != null) {
					this.checkBoxRenderer.setText(value.toString());
					DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) value;
					Object userObject = treeNode.getUserObject();
					if (userObject instanceof DataTreeNode) {
						DataTreeNode node = (DataTreeNode) userObject;
						this.checkBoxRenderer.setText(node.getText());
						this.checkBoxRenderer.setSelected(node.isSelected());
						Icon icon = null;
						if (node.isSelected()) {
							final boolean allChildSelected = node.isAllChildNodesSelected();
							icon = allChildSelected ? this.fullySelectedIcon : partiallySelectedIcon;
						} else {
							final boolean childSelected = node.isChildNodeSelected();
							icon = childSelected ? this.onlyChildSelectedIcon : this.unselectedIcon;
						}
						this.checkBoxRenderer.setIcon(icon);
					}
				}
				returnValue = this.checkBoxRenderer;
				this.neglectItemEvent = false;
			}
			return returnValue;
		}
	}

	class DataTreeCellEditor extends AbstractCellEditor implements
			TreeCellEditor, ItemListener {

		private static final long serialVersionUID = -3622575879072448810L;

		private DataTreeCellRenderer renderer = new DataTreeCellRenderer();

		private int stateCounter = 0;
		
		public DataTreeCellEditor() {
			super();
		}

		@Override
		public Object getCellEditorValue() {
			JCheckBox checkbox = renderer.getCheckBoxRenderer();
			TreeNode selectedNode = (TreeNode) getSelectedNode();
			if (selectedNode instanceof DataTreeNode) {
				((DataTreeNode) selectedNode).setSelected(checkbox.isSelected());
			}
			return selectedNode;
		}

		@Override
		public Component getTreeCellEditorComponent(JTree tree, Object value,
				boolean selected, boolean expanded, boolean leaf, int row) {
			
			Component editor = renderer.getTreeCellRendererComponent(tree,
					value, true, expanded, leaf, row, true);
			if (editor instanceof JCheckBox) {
				JCheckBox checkBox = (JCheckBox) editor;
				ItemListener[] listeners = checkBox.getItemListeners();
				if (!SGUtility.contains(listeners, this)) {
					checkBox.addItemListener(this);
				}
			}
			return editor;
		}
		
		@Override
		public void itemStateChanged(final ItemEvent itemEvent) {
			if (this.stopCellEditing()) {
				if (this.renderer.neglectItemEvent) {
					return;
				}
				SwingUtilities.invokeLater(new Runnable() {
					public void run() {
						TreePath selectedPath = mDataTree.getSelectionPath();
						final int pathCnt = selectedPath.getPathCount();
						if (pathCnt == 2) {
							DataTreeNode selectedNode = (DataTreeNode) getSelectedNode();
							final boolean selected = selectedNode.isSelected();
							switch (stateCounter) {
							case 0:
							case 1:
								// do nothing
								break;
							case 2:
							case 3:
								// select or deselect the child nodes
								for (int ii = 0; ii < selectedNode.getChildCount(); ii++) {
									DataTreeNode childNode = (DataTreeNode) selectedNode.getChildAt(ii);
									childNode.setSelected(selected);
								}
								break;
							default:
							}
							
							// updates the counter
							stateCounter++;
							stateCounter %= 4;
						}
						mDataTree.repaint();

						// synchronizes the tree and table
						syncDataTable();
					}
				});
			}
		}
	}
	
	/**
	 * Synchronizes the tree and the table.
	 * 
	 */
	void syncDataTable() {
		// finds selected nodes
		List<DataTreeNode> nodeList = new ArrayList<DataTreeNode>();
		TreeNode root = (TreeNode) this.mDataTreeModel.getRoot();
		for (int ii = 0; ii < root.getChildCount(); ii++) {
			DataTreeNode childNode = (DataTreeNode) root.getChildAt(ii);
			if (childNode.isSelected()) {
				nodeList.add(childNode);
				// grandchild nodes are neglected
			} else {
				for (int jj = 0; jj < childNode.getChildCount(); jj++) {
					DataTreeNode grandChildNode = (DataTreeNode) childNode.getChildAt(jj);
					if (grandChildNode.isSelected()) {
						nodeList.add(grandChildNode);
					}					
				}
			}
		}

		// compares current nodes and new nodes because multiple ItemEvent is invoked
		Set<DataTreeNode> newSet = new HashSet<DataTreeNode>();
		newSet.addAll(nodeList);
		Set<DataTreeNode> curSet = new HashSet<DataTreeNode>();
		curSet.addAll(this.mTableTreeNodeList);
		if (curSet.equals(newSet)) {
			// do nothing
			return;
		}
		
		this.mTableTreeNodeList.clear();
		this.mTableTreeNodeList.addAll(nodeList);

		for (int ii = this.mDataTableModel.getRowCount() - 1; ii >=0; ii--) {
			this.mDataTableModel.removeRow(ii);
		}
		for (int ii = 0; ii < nodeList.size(); ii++) {
			DataTreeNode node = nodeList.get(ii);
			String dataType = node.getDataType();
			this.mDataTableModel.addRow(ii, node.getText(), 
					SGDataTypeConstants.getLongDataTypeConstant(dataType));
		}
	}
	
	static class WrappedData {
		private SGData data = null;

		private SGDataBuffer buffer = null;
		
		public WrappedData(SGData data) {
			super();
			this.data = data;
		}
		
		public WrappedData(SGDataBuffer buffer) {
			super();
			this.buffer = buffer;
		}
		
		public SGData getData() {
			return this.data;
		}
		
		public SGDataBuffer getDataBuffer() {
			return this.buffer;
		}
	}

	static class DataTreeNode extends DefaultMutableTreeNode {
		private static final long serialVersionUID = -451646821490528695L;
		
		private boolean selected = false;
		
		private String text = null;
		
		private WrappedData wData = null;
		
		public DataTreeNode(String text, WrappedData wData) {
			super();
			this.text = text;
			this.wData = wData;
			this.setUserObject(this);
		}
		
		public String getText() {
			return this.text;
		}
		
		public boolean isSelected() {
			return this.selected;
		}
		
		public void setSelected(final boolean b) {
			this.selected = b;
		}
		
		public SGData getData() {
			return this.wData.getData();
		}
		
		public String getDataType() {
			SGData data = this.wData.getData();
			String dataType = null;
			if (data != null) {
				dataType = data.getDataType();
			} else {
				SGDataBuffer buffer = this.wData.getDataBuffer();
				if (buffer != null) {
					dataType = buffer.getDataType();
				}
			}
			return dataType;
		}
		
		public SGDataBuffer getDataBuffer() {
			SGDataBuffer ret = null;
			SGDataBuffer buffer = this.wData.getDataBuffer();
			if (buffer != null) {
				if (SGDataUtility.isMultipleData(buffer.getDataType())) {
					SGSXYMultipleDataBuffer sxyBuffer = (SGSXYMultipleDataBuffer) buffer;
					if (sxyBuffer.getMultiplicity() > 1) {
						ret = sxyBuffer.pickUp(this.getIndices());
					} else {
						ret = buffer;
					}
				} else {
					ret = buffer;
				}
			} else {
				final boolean all = true;
				final boolean removeInvalidValues = true;
				final boolean editedValuesReflected = true;
				final boolean shift = true;
				final boolean takeAllStride = false;
				SGData data = this.wData.getData();
				String dataType = data.getDataType();
				if (SGDataUtility.isSXYTypeData(dataType)) {
					if (SGDataUtility.isMultipleData(dataType)) {
						SGISXYTypeMultipleData mData = (SGISXYTypeMultipleData) data;
						final int num = mData.getChildNumber();
						if (num == 1) {
							SGISXYTypeSingleData[] sxyArray = mData.getSXYDataArray();
							ret = sxyArray[0].getDataBuffer(new SGSXYDataBufferPolicy(
									all, removeInvalidValues, editedValuesReflected, 
									shift, takeAllStride));
							
					    	// disposes of data objects
					        SGDataUtility.disposeSXYDataArray(sxyArray);
						} else if (num > 1) {
							ret = mData.getDataBuffer(new SGSXYDataBufferPolicy(all, 
									removeInvalidValues, editedValuesReflected, shift, takeAllStride), 
									this.getIndices());
						}
					} else {
						ret = data.getDataBuffer(new SGSXYDataBufferPolicy(all, 
								removeInvalidValues, editedValuesReflected, shift, takeAllStride));
					}
				} else {
					ret = data.getDataBuffer(new SGDataBufferPolicy(all, removeInvalidValues,
							editedValuesReflected));
				}
			}
			return ret;
		}
		
		private int[] getIndices() {
			List<Integer> indexList = new ArrayList<Integer>();
			for (int ii = 0; ii < this.getChildCount(); ii++) {
				DataTreeNode childNode = (DataTreeNode) this.getChildAt(ii);
				if (childNode.isSelected()) {
					indexList.add(ii);
				}
			}
			int[] indices = new int[indexList.size()];
			for (int ii = 0; ii < indices.length; ii++) {
				indices[ii] = indexList.get(ii);
			}
			return indices;
		}
		
		@Override
		public String toString() {
			return this.text;
		}
		
		private boolean isChildNodeSelected() {
			boolean childSelected = false;
			for (int ii = 0; ii < this.getChildCount(); ii++) {
				DataTreeNode childNode = (DataTreeNode) this.getChildAt(ii);
				if (childNode.isSelected()) {
					childSelected = true;
					break;
				}
			}
			return childSelected;
		}
		
		private boolean isAllChildNodesSelected() {
			for (int ii = 0; ii < this.getChildCount(); ii++) {
				DataTreeNode childNode = (DataTreeNode) this.getChildAt(ii);
				if (!childNode.isSelected()) {
					return false;
				}
			}
			return true;
		}
	}

    // Currently dragged row index.
    private int mDraggedRow = -1;

    // The list of tree nodes selected in the tree.
	private List<DataTreeNode> mTableTreeNodeList = new ArrayList<DataTreeNode>();
	
	@Override
	public void mouseClicked(MouseEvent e) {
		// do nothing
	}

	@Override
	public void mousePressed(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mDataTable)) {
			Point pos = e.getPoint();
			final int row = this.mDataTable.rowAtPoint(pos);
			this.mDraggedRow = row;
		}
	}

	@Override
	public void mouseReleased(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mDataTable)) {
			this.mDraggedRow = -1;
		}
	}

	@Override
	public void mouseEntered(MouseEvent e) {
		// do nothing
	}

	@Override
	public void mouseExited(MouseEvent e) {
		// do nothing
	}

	@Override
	public void mouseDragged(MouseEvent e) {
		Object source = e.getSource();
		if (source.equals(this.mDataTable)) {
			Point pos = e.getPoint();
			final int row = this.mDataTable.rowAtPoint(pos);
			if (row != -1) {
				if (this.mDraggedRow == row) {
					return;
				}
				
				// updates the list of attribute
				DataTreeNode node = this.mTableTreeNodeList.remove(this.mDraggedRow);
				this.mTableTreeNodeList.add(row, node);
				
				// updates the table model
				this.mDataTableModel.moveRow(this.mDraggedRow, this.mDraggedRow, row);
				this.mDraggedRow = row;
			}
			
			// updates the serial numbers
			final int colIndex = this.mDataTableModel.findColumn(COLUMN_NAME_NUMBER);
			for (int ii = 0; ii < this.mDataTableModel.getRowCount(); ii++) {
				this.mDataTableModel.setValueAt(Integer.toString(ii + 1), ii, colIndex);
			}
		}
	}
	
	@Override
	public void mouseMoved(MouseEvent e) {
		// do nothing
	}

    class NumberCellRenderer extends DefaultTableCellRenderer {
    	
		private static final long serialVersionUID = 3834766723190038427L;

		public NumberCellRenderer() {
    		super();
    	}
    	
		@Override
		public Component getTableCellRendererComponent(JTable table,
				Object value, boolean isSelected, boolean hasFocus, int row,
				int column) {
			JTableHeader header = mDataTable.getTableHeader();
			this.setBackground(header.getBackground());
			this.setForeground(header.getForeground());
			return super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
		}
    }

    /**
     * Returns an array of data buffers of selected data.
     * 
     * @return an array of data buffers of selected data
     */
    public NamedDataBuffer[] getSelectedDataBuffers() {
    	NamedDataBuffer[] buffers = new NamedDataBuffer[this.mTableTreeNodeList.size()];
		for (int ii = 0; ii < buffers.length; ii++) {
			DataTreeNode node = this.mTableTreeNodeList.get(ii);
			buffers[ii] = new NamedDataBuffer(node.getText(), node.getDataBuffer());
		}
    	return buffers;
    }

    static class NamedDataBuffer {
    	private String name;
    	
    	private SGDataBuffer dataBuffer;
    	
    	public NamedDataBuffer(String name, SGDataBuffer dataBuffer) {
    		super();
    		this.name = name;
    		this.dataBuffer = dataBuffer;
    	}
    	
    	public String getName() {
    		return this.name;
    	}
    	
    	public SGDataBuffer getDataBuffer() {
    		return this.dataBuffer;
    	}
    }
}
