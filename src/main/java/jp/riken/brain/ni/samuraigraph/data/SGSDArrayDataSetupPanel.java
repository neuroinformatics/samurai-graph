package jp.riken.brain.ni.samuraigraph.data;

import java.awt.Component;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ItemListener;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.swing.BorderFactory;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;
import javax.swing.border.TitledBorder;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.text.Document;

import jp.riken.brain.ni.samuraigraph.base.SGComponentGroup;
import jp.riken.brain.ni.samuraigraph.base.SGComponentGroupElement;
import jp.riken.brain.ni.samuraigraph.base.SGDataColumnInfo;
import jp.riken.brain.ni.samuraigraph.base.SGDataColumnInfoSet;
import jp.riken.brain.ni.samuraigraph.base.SGIntegerSeriesSet;
import jp.riken.brain.ni.samuraigraph.base.SGUtility;

/**
 *
 */
public class SGSDArrayDataSetupPanel extends SGDataSetupPanel implements DocumentListener {

	private static final long serialVersionUID = 5298005129734069206L;

	/** Creates new form SGArrayDataSetupPanel */
    public SGSDArrayDataSetupPanel() {
    	super();
        initComponents();
        this.initProperty();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mDataColumnSelectionPanel = new jp.riken.brain.ni.samuraigraph.data.SGSDArrayDataColumnSelectionPanel();
        mTabbedPane = new javax.swing.JTabbedPane();
        mStrideTabPanel = new javax.swing.JPanel();
        mStrideSubPanel = new javax.swing.JPanel();
        mStrideAvailableCheckBox = new jp.riken.brain.ni.samuraigraph.base.SGCheckBox();
        mStrideContainerPanel = new javax.swing.JPanel();
        mStridePanel = new javax.swing.JPanel();
        mIndexStridePanel = new jp.riken.brain.ni.samuraigraph.data.SGIndexPanel();
        mTickLabelStrideParentPanel = new javax.swing.JPanel();
        mTickLabelStrideSyncCheckBox = new jp.riken.brain.ni.samuraigraph.base.SGCheckBox();
        mTickLabelStridePanel = new jp.riken.brain.ni.samuraigraph.data.SGIndexPanel();

        setLayout(new java.awt.GridBagLayout());
        add(mDataColumnSelectionPanel, new java.awt.GridBagConstraints());

        mTabbedPane.setFont(new java.awt.Font("Dialog", 1, 12)); // NOI18N

        mStrideTabPanel.setLayout(new java.awt.BorderLayout());

        mStrideSubPanel.setLayout(new java.awt.GridBagLayout());

        mStrideAvailableCheckBox.setText("Available");
        mStrideAvailableCheckBox.setFont(new java.awt.Font("Dialog", 0, 12));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        mStrideSubPanel.add(mStrideAvailableCheckBox, gridBagConstraints);

        mStrideContainerPanel.setLayout(new java.awt.GridBagLayout());

        mStridePanel.setLayout(new java.awt.GridBagLayout());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.VERTICAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        mStridePanel.add(mIndexStridePanel, gridBagConstraints);

        mTickLabelStrideParentPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Tick Label", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Dialog", 0, 12))); // NOI18N
        mTickLabelStrideParentPanel.setLayout(new java.awt.GridBagLayout());

        mTickLabelStrideSyncCheckBox.setText("Sync");
        mTickLabelStrideSyncCheckBox.setFont(new java.awt.Font("Dialog", 0, 12));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        mTickLabelStrideParentPanel.add(mTickLabelStrideSyncCheckBox, gridBagConstraints);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        mTickLabelStrideParentPanel.add(mTickLabelStridePanel, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        mStridePanel.add(mTickLabelStrideParentPanel, gridBagConstraints);

        mStrideContainerPanel.add(mStridePanel, new java.awt.GridBagConstraints());

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        mStrideSubPanel.add(mStrideContainerPanel, gridBagConstraints);

        mStrideTabPanel.add(mStrideSubPanel, java.awt.BorderLayout.NORTH);

        mTabbedPane.addTab("Array Section", mStrideTabPanel);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        add(mTabbedPane, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    private SGComponentGroup mTickLabelStrideComponentGroup = new SGComponentGroup();

    private SGComponentGroup mTickLabelComponentGroup = new SGComponentGroup();

    private SGComponentGroup mGridComponentGroup = new SGComponentGroup();

    private SGComponentGroup mStrideComponentGroup = new SGComponentGroup();

    private void initProperty() {
    	this.addDocumentListener(this);
    	this.mStrideAvailableCheckBox.addActionListener(this);
    	this.mTickLabelStrideSyncCheckBox.addActionListener(this);

        Component[] strideComponentArray = {
        		this.mIndexStridePanel,
        		this.mTickLabelStrideSyncCheckBox,
        		this.mTickLabelStridePanel
        };

        // creates a map of component groups
        Map<Component, SGComponentGroupElement> compMap = new HashMap<Component, SGComponentGroupElement>();
        for (Component com : strideComponentArray) {
            this.addComponentGroupMap(com, compMap);
        }

		List<SGComponentGroupElement> tickLabelStrideComponents = new ArrayList<SGComponentGroupElement>();
		tickLabelStrideComponents.add(compMap.get(this.mTickLabelStridePanel));
		List<SGComponentGroupElement> tickLabelComponents = new ArrayList<SGComponentGroupElement>();
		tickLabelComponents.addAll(tickLabelStrideComponents);
		tickLabelComponents.add(compMap.get(this.mTickLabelStrideSyncCheckBox));
		this.mTickLabelStrideComponentGroup.addElement(tickLabelStrideComponents);
		this.mTickLabelComponentGroup.addElement(tickLabelComponents);

		List<SGComponentGroupElement> gridStrideComponents = new ArrayList<SGComponentGroupElement>();
		gridStrideComponents.add(compMap.get(this.mIndexStridePanel));
		this.mGridComponentGroup.addElement(gridStrideComponents);

		this.mStrideComponentGroup.addElement(gridStrideComponents);
		this.mStrideComponentGroup.addElement(tickLabelComponents);
    }

    private void addComponentGroupMap(Component comp, Map<Component, SGComponentGroupElement> map) {
    	map.put(comp, new SGComponentGroupElement(comp));
    }

    /**
     * The data source.
     */
    private SGSDArrayFile mSDArrayFile = null;

	@Override
	public boolean checkSelectedItems() {
        // check selected items of the table
		SGDataColumnSelectionPanel selectionPanel = this.getDataColumnSelectionPanel();
        if (selectionPanel.checkSelectedItems() == false) {
            return false;
        }

        if (!this.mIndexStridePanel.hasValidInput()) {
        	String msg = "";
        	if (SGDataUtility.isSXYTypeData(this.mDataType)) {
        		msg = SGDataUtility.MSG_PROPER_STRIDE_LINE_AND_BAR;
        	} else if (SGDataUtility.isSXYZTypeData(this.mDataType)
        			|| SGDataUtility.isVXYTypeData(this.mDataType)) {
        		msg = SGDataUtility.MSG_PROPER_STRIDE;
        	}
        	selectionPanel.setMessage(msg);
        	return false;
        }
        if (SGDataUtility.isSXYTypeData(this.mDataType)) {
            if (this.isTickLabelAvailable()) {
                if (!this.mTickLabelStridePanel.hasValidInput()) {
                	selectionPanel.setMessage(SGDataUtility.MSG_PROPER_STRIDE_TICK_LABEL);
                	return false;
                }
            }
        }

        // clears the message
        selectionPanel.clearMessage();

		return true;
	}

    private boolean isTickLabelAvailable() {
    	return this.isTickLabelAvailable(this.getDataColumnInfoArray());
    }

    private boolean isTickLabelAvailable(SGDataColumnInfo[] cols) {
		List<SGDataColumnInfo> tickLabelColumnList = this.findColumnsWithColumnTypeStartsWith(
				cols, TICK_LABEL);
		if (tickLabelColumnList.size() > 0) {
			return true;
		}
		List<SGDataColumnInfo> dateColumnList = this.findColumnsWithValueType(
				cols, VALUE_TYPE_DATE);
		if (dateColumnList.size() > 0) {
			return true;
		}
		return false;
    }

	@Override
	protected JScrollPane getOriginScrollPane() {
		// always returns null
		return null;
	}

	@Override
	protected SGDataColumnSelectionPanel getDataColumnSelectionPanel() {
		return this.mDataColumnSelectionPanel;
	}

	@Override
	public SGDataColumnInfo[] getDataColumnTypes() {
		return this.getDataColumnInfoArray();
	}

    /**
     * Updates the components with variables in the table.
     *
     */
	@Override
	protected void updateComponentsWithTable() {
        // create a list of the names of selected variables
        SGDataColumnInfo[] cols = this.getDataColumnInfoArray();
        
        // refresh the columns that error bars and tick labels are appended
        this.clearUselessColumnType(cols);

        // set enabled / disabled the panel for the stride of tick labels
        final boolean tickLabelAvailable = this.isTickLabelAvailable(cols);
        this.mTickLabelComponentGroup.setEnabled(tickLabelAvailable);
	}

	@Override
	public void addDocumentListener(DocumentListener l) {
		this.mIndexStridePanel.addDocumentListener(l);
		this.mTickLabelStridePanel.addDocumentListener(l);
	}

	@Override
	public void addItemListener(ItemListener l) {
		// do nothing
	}

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private jp.riken.brain.ni.samuraigraph.data.SGSDArrayDataColumnSelectionPanel mDataColumnSelectionPanel;
    private jp.riken.brain.ni.samuraigraph.data.SGIndexPanel mIndexStridePanel;
    private jp.riken.brain.ni.samuraigraph.base.SGCheckBox mStrideAvailableCheckBox;
    private javax.swing.JPanel mStrideContainerPanel;
    private javax.swing.JPanel mStridePanel;
    private javax.swing.JPanel mStrideSubPanel;
    private javax.swing.JPanel mStrideTabPanel;
    private javax.swing.JTabbedPane mTabbedPane;
    private jp.riken.brain.ni.samuraigraph.data.SGIndexPanel mTickLabelStridePanel;
    private javax.swing.JPanel mTickLabelStrideParentPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGCheckBox mTickLabelStrideSyncCheckBox;
    // End of variables declaration//GEN-END:variables

    /**
     * Set information of data columns.
     *
     * @param data
     *            single dimensional data
     * @param colInfoSet
     *            data columns
     * @param infoMap
     *            a map of information
     * @param showDefault
     *            a flag whether to show default column type
     * @return true if succeeded
     */
    public boolean setData(SGSDArrayData data,
            SGDataColumnInfoSet colInfoSet,
            Map<String, Object> infoMap, final boolean showDefault) {
        if (this.setData((SGSDArrayFile) data.getDataSource(), data.getDataType(), colInfoSet,
        		infoMap, showDefault) == false) {
            return false;
        }
        return true;
    }

    /**
     * Set information of data columns.
     *
     * @param dataType
     *            data type
     * @param colInfoSet
     *            data columns
     * @param infoMap
     *            a map of information
     * @param showDefault
     *            a flag whether to show default column type
     * @return true if succeeded
     */
    public boolean setData(final SGSDArrayFile sdFile, String dataType,
            SGDataColumnInfoSet colInfoSet,
            Map<String, Object> infoMap, final boolean showDefault) {

        // check input values
        if (dataType == null || colInfoSet == null
                || infoMap == null) {
            throw new IllegalArgumentException(
                    "file == null || dataType == null || colInfoSet == null || infoMap == null");
        }

        // put the data source into a map
        infoMap.put(SGIDataInformationKeyConstants.KEY_DATA_SOURCE, sdFile);

        // clear all
        this.clear();

        // set to the attribute
        this.mSDArrayFile = sdFile;
        this.mDataType = dataType;
        this.mInfoMap = new HashMap<String, Object>(infoMap);
        this.mInfoMap.put(SGIDataInformationKeyConstants.KEY_DATA_TYPE, dataType);

        // setup the table
        if (this.mDataColumnSelectionPanel.setData(dataType, colInfoSet, infoMap,
                showDefault) == false) {
            return false;
        }

        boolean tickLabelVisible = false;
        if (SGDataUtility.isSXYTypeData(dataType)) {
        	tickLabelVisible = true;
        	this.mIndexStridePanel.setBorder(BorderFactory.createTitledBorder(
        			null, "Line and Bar", TitledBorder.DEFAULT_JUSTIFICATION,
        			TitledBorder.DEFAULT_POSITION, new Font("Dialog", 0, 12)));
        } else if (SGDataUtility.isVXYTypeData(dataType)) {
        	tickLabelVisible = false;
        	this.mIndexStridePanel.setBorder(null);
        } else if (SGDataUtility.isSXYZTypeData(dataType)) {
        	tickLabelVisible = false;
        	this.mIndexStridePanel.setBorder(null);
        }
        this.mTickLabelStrideParentPanel.setVisible(tickLabelVisible);

        // updates the parameters for stride of arrays
        SwingUtilities.invokeLater(new Runnable() {
        	public void run() {
        		initStride();
        	}
        });

        // initializes stride components
        final Boolean strideAvailable = (Boolean) infoMap.get(
        		SGIDataInformationKeyConstants.KEY_STRIDE_AVAILABLE);
        final boolean b;
        if (strideAvailable != null) {
        	b = strideAvailable.booleanValue();
        } else {
        	b = false;
        }
        this.mStrideAvailableCheckBox.setSelected(b);
        this.mStrideComponentGroup.setEnabled(b);

        // update the components
        this.updateComponentsWithTable();

    	return true;
    }

	private void initStride() {
		SGDataColumnInfo[] cols = this.getDataColumnInfoArray();
		String keyStride;
		if (SGDataUtility.isSXYTypeData(this.mDataType)) {
			keyStride = SGIDataInformationKeyConstants.KEY_SXY_INDEX_STRIDE;
		} else if (SGDataUtility.isSXYZTypeData(this.mDataType)) {
			keyStride = SGIDataInformationKeyConstants.KEY_SXYZ_INDEX_STRIDE;
		} else if (SGDataUtility.isVXYTypeData(this.mDataType)) {
			keyStride = SGIDataInformationKeyConstants.KEY_VXY_INDEX_STRIDE;
		} else {
			return;
		}
		SGSDArrayFile sdFile = (SGSDArrayFile) this.mInfoMap.get(SGIDataInformationKeyConstants.KEY_DATA_SOURCE);
		final int len = sdFile.getLength();
		SGIntegerSeriesSet stride = (SGIntegerSeriesSet) this.mInfoMap.get(keyStride);
		if (stride == null) {
			Map<String, SGIntegerSeriesSet> strideMap = SGDataUtility.calcSDArrayDefaultStride(cols, this.mInfoMap);
			stride = strideMap.get(keyStride);
		} else {
			stride = SGUtility.createIndicesWithinRange(stride, len);
		}
		this.mIndexStridePanel.setLength(len);
		this.mIndexStridePanel.setIndices(stride);

		if (SGDataUtility.isSXYTypeData(this.mDataType)) {
			// tick label
			this.initTickLabelStride(stride, len, cols);
		}
	}

	// Initializes the stride for tick labels.
	private void initTickLabelStride(final SGIntegerSeriesSet stride, final int len,
			SGDataColumnInfo[] cols) {
		SGIntegerSeriesSet strideTickLabel = (SGIntegerSeriesSet) this.mInfoMap
				.get(SGIDataInformationKeyConstants.KEY_SXY_TICK_LABEL_STRIDE);
		boolean sync = SGUtility.equals(strideTickLabel, stride);
		if (strideTickLabel == null) {
			// synchronize with main stride
			strideTickLabel = stride;
			sync = true;
		} else {
			strideTickLabel = SGUtility.createIndicesWithinRange(strideTickLabel, len);
		}
		this.mTickLabelStridePanel.setLength(len);
		this.mTickLabelStridePanel.setIndices(strideTickLabel);
		this.mTickLabelStrideSyncCheckBox.setSelected(sync);
		this.mTickLabelStrideComponentGroup.setEnabled(!sync);
	}

	@Override
	public Boolean isVariableDataType() {
		// always returns null;
		return null;
	}

    /**
     * Returns the indices for picked up dimension of scalar XY data.
     *
     * @return the indices for picked up dimension of scalar XY data
     */
	@Override
	public SGIntegerSeriesSet getSXYPickUpIndices() {
		// always returns null;
		return null;
	}

	@Override
	public void valueChanged(ListSelectionEvent e) {
		// do nothing
	}

    /**
     * Returns the map of the stride for arrays.
     *
     * @return the map of the stride for arrays
     */
	@Override
    public Map<String, SGIntegerSeriesSet> getStrideMap() {
		Map<String, SGIntegerSeriesSet> strideMap = new HashMap<String, SGIntegerSeriesSet>();
		if (SGDataUtility.isSXYTypeData(this.mDataType)) {
			this.updateStrideMap(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_SXY_INDEX_STRIDE, strideMap);
			this.updateStrideMap(this.mTickLabelStridePanel,
					SGIDataInformationKeyConstants.KEY_SXY_TICK_LABEL_STRIDE, strideMap);
		} else if (SGDataUtility.isSXYZTypeData(this.mDataType)) {
			this.updateStrideMap(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_SXYZ_INDEX_STRIDE, strideMap);
		} else if (SGDataUtility.isVXYTypeData(this.mDataType)) {
			this.updateStrideMap(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_VXY_INDEX_STRIDE, strideMap);
		}
		return strideMap;
    }
	
	@Override
	protected void setStrideMap(Map<String, SGIntegerSeriesSet> strideMap) {
		if (SGDataUtility.isSXYTypeData(this.mDataType)) {
			this.setStride(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_SXY_INDEX_STRIDE, strideMap);
			this.setStride(this.mTickLabelStridePanel,
					SGIDataInformationKeyConstants.KEY_SXY_TICK_LABEL_STRIDE, strideMap);
		} else if (SGDataUtility.isSXYZTypeData(this.mDataType)) {
			this.setStride(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_SXYZ_INDEX_STRIDE, strideMap);
		} else if (SGDataUtility.isVXYTypeData(this.mDataType)) {
			this.setStride(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_VXY_INDEX_STRIDE, strideMap);
		}
	}
	
	@Override
	protected Map<String, Integer> getFullLengthMap() {
		Map<String, Integer> lengthMap = new HashMap<String, Integer>();
		if (SGDataUtility.isSXYTypeData(this.mDataType)) {
			this.updateLengthMap(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_SXY_INDEX_STRIDE,
					lengthMap);
			this.updateLengthMap(this.mTickLabelStridePanel,
					SGIDataInformationKeyConstants.KEY_SXY_TICK_LABEL_STRIDE,
					lengthMap);
		} else if (SGDataUtility.isSXYZTypeData(this.mDataType)) {
			this.updateLengthMap(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_SXYZ_INDEX_STRIDE,
					lengthMap);
		} else if (SGDataUtility.isVXYTypeData(this.mDataType)) {
			this.updateLengthMap(this.mIndexStridePanel,
					SGIDataInformationKeyConstants.KEY_VXY_INDEX_STRIDE,
					lengthMap);
		}
		return lengthMap;
	}

    /**
     * Returns whether stride of data arrays is available.
     *
     * @return true if stride of data arrays is available
     */
    public boolean isStrideAvailable() {
    	return this.mStrideAvailableCheckBox.isSelected();
    }

	@Override
	public void insertUpdate(DocumentEvent e) {
		this.onDocumentUpdate(e);
	}

	@Override
	public void removeUpdate(DocumentEvent e) {
		this.onDocumentUpdate(e);
	}

	@Override
	public void changedUpdate(DocumentEvent e) {
		this.onDocumentUpdate(e);
	}

	private void onDocumentUpdate(DocumentEvent e) {
		Document doc = e.getDocument();
		if (this.mIndexStridePanel.hasDocument(doc)) {
			this.syncTickLabelStride();
		}
	}

	// Synchronizes the stride for tick labels.
	private void syncTickLabelStride() {
		if (this.mTickLabelStrideSyncCheckBox.isSelected()) {
			SGIntegerSeriesSet indices = this.mIndexStridePanel.getIndices();
			this.mTickLabelStridePanel.setLength(this.mIndexStridePanel.getLength());
			this.mTickLabelStridePanel.setIndices(indices);
		}
	}

    /**
     * Called when an action event is generated.
     * @param e
     *         an action event
     */
    public void actionPerformed(ActionEvent e) {
    	super.actionPerformed(e);

    	Object source = e.getSource();
    	if (source.equals(this.mTickLabelStrideSyncCheckBox)) {
    		final boolean bSync = this.mTickLabelStrideSyncCheckBox.isSelected();
    		this.mTickLabelStrideComponentGroup.setEnabled(!bSync);

    		// synchronizes the stride
    		if (bSync) {
    			this.syncTickLabelStride(this.mIndexStridePanel);
    		}
    	} else if (source.equals(this.mStrideAvailableCheckBox)) {
    		final boolean enabled = this.mStrideAvailableCheckBox.isSelected();
    		this.mStrideComponentGroup.setEnabled(enabled);
    	}
    }

	// Synchronizes the stride for tick labels.
	private void syncTickLabelStride(SGIndexPanel p) {
		if (this.mTickLabelStrideSyncCheckBox.isSelected()) {
			this.mTickLabelStridePanel.setLength(p.getLength());
			this.mTickLabelStridePanel.setIndices(p.getIndices());
		}
	}

}
