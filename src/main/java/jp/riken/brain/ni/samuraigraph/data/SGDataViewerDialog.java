package jp.riken.brain.ni.samuraigraph.data;

import java.awt.Component;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.BorderFactory;
import javax.swing.DefaultCellEditor;
import javax.swing.JMenu;
import javax.swing.JPopupMenu;
import javax.swing.JScrollBar;
import javax.swing.JTable;
import javax.swing.JTextField;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableCellEditor;
import javax.swing.table.TableColumn;

import jp.riken.brain.ni.samuraigraph.base.SGData;
import jp.riken.brain.ni.samuraigraph.base.SGDialog;
import jp.riken.brain.ni.samuraigraph.base.SGIConstants;
import jp.riken.brain.ni.samuraigraph.base.SGIPlugin;
import jp.riken.brain.ni.samuraigraph.base.SGIPluginManager;
import jp.riken.brain.ni.samuraigraph.base.SGIntegerSeries;
import jp.riken.brain.ni.samuraigraph.base.SGIntegerSeriesSet;
import jp.riken.brain.ni.samuraigraph.base.SGSimpleIndexBlock;
import jp.riken.brain.ni.samuraigraph.base.SGTwoDimensionalArrayIndex;
import jp.riken.brain.ni.samuraigraph.base.SGUtility;
import jp.riken.brain.ni.samuraigraph.base.SGXYSimpleIndexBlock;

/**
 * Data Viewer dialog.
 *
 */
public class SGDataViewerDialog extends SGDialog {

	private static final long serialVersionUID = 8617253276875786169L;
    
    /**
     * Creates new form SGDataViewerDialog
     */
    public SGDataViewerDialog(java.awt.Frame parent, boolean modal) {
        super(parent, modal);
        initComponents();
        this.initProperty();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        mBottomPanel = new javax.swing.JPanel();
        mBottomInnerEastPanel = new javax.swing.JPanel();
        mCloseButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();
        mBottomInnerWestPanel = new javax.swing.JPanel();
        mClearSelectionButton = new jp.riken.brain.ni.samuraigraph.base.SGButton();
        mHighlightDataCheckBox = new jp.riken.brain.ni.samuraigraph.base.SGCheckBox();
        mHideEmptyCellsCheckBox = new jp.riken.brain.ni.samuraigraph.base.SGCheckBox();
        mScrollPane = new javax.swing.JScrollPane();
        mTable = new DataViewerTable();
        mTopPanel = new javax.swing.JPanel();
        mTopInnerPanel = new javax.swing.JPanel();
        mColumnTypeComboBox = new jp.riken.brain.ni.samuraigraph.base.SGComboBox();
        mColumnTypeLabel = new javax.swing.JLabel();
        mTextField = new jp.riken.brain.ni.samuraigraph.base.SGTextField();

        mBottomPanel.setLayout(new java.awt.BorderLayout());

        mBottomInnerEastPanel.setLayout(new java.awt.GridBagLayout());

        mCloseButton.setText(CLOSE_BUTTON_TEXT);
        mCloseButton.setFont(new java.awt.Font("Dialog", 1, 12)); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        mBottomInnerEastPanel.add(mCloseButton, gridBagConstraints);

        mBottomPanel.add(mBottomInnerEastPanel, java.awt.BorderLayout.EAST);

        mBottomInnerWestPanel.setLayout(new java.awt.GridBagLayout());

        mClearSelectionButton.setText("Deselect");
        mClearSelectionButton.setFont(new java.awt.Font("Dialog", 1, 12)); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        mBottomInnerWestPanel.add(mClearSelectionButton, gridBagConstraints);

        mHighlightDataCheckBox.setText("Highlight Data");
        mHighlightDataCheckBox.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        mBottomInnerWestPanel.add(mHighlightDataCheckBox, gridBagConstraints);

        mHideEmptyCellsCheckBox.setText("Hide Empty Cells");
        mHideEmptyCellsCheckBox.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        mBottomInnerWestPanel.add(mHideEmptyCellsCheckBox, gridBagConstraints);

        mBottomPanel.add(mBottomInnerWestPanel, java.awt.BorderLayout.WEST);

        getContentPane().add(mBottomPanel, java.awt.BorderLayout.SOUTH);

        mScrollPane.setPreferredSize(new java.awt.Dimension(454, 250));

        mTable.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        mTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {

            }
        ));
        mScrollPane.setViewportView(mTable);

        getContentPane().add(mScrollPane, java.awt.BorderLayout.CENTER);

        mTopPanel.setLayout(new java.awt.BorderLayout());

        mTopInnerPanel.setLayout(new java.awt.GridBagLayout());

        mColumnTypeComboBox.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        mColumnTypeComboBox.setPreferredSize(new java.awt.Dimension(100, 24));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        mTopInnerPanel.add(mColumnTypeComboBox, gridBagConstraints);

        mColumnTypeLabel.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        mColumnTypeLabel.setText("Column Type");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 0);
        mTopInnerPanel.add(mColumnTypeLabel, gridBagConstraints);

        mTextField.setColumns(18);
        mTextField.setEditable(false);
        mTextField.setFont(new java.awt.Font("Dialog", 0, 12)); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 10, 5, 5);
        mTopInnerPanel.add(mTextField, gridBagConstraints);

        mTopPanel.add(mTopInnerPanel, java.awt.BorderLayout.WEST);

        getContentPane().add(mTopPanel, java.awt.BorderLayout.PAGE_START);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel mBottomInnerEastPanel;
    private javax.swing.JPanel mBottomInnerWestPanel;
    private javax.swing.JPanel mBottomPanel;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mClearSelectionButton;
    private jp.riken.brain.ni.samuraigraph.base.SGButton mCloseButton;
    private jp.riken.brain.ni.samuraigraph.base.SGComboBox mColumnTypeComboBox;
    private javax.swing.JLabel mColumnTypeLabel;
    private jp.riken.brain.ni.samuraigraph.base.SGCheckBox mHideEmptyCellsCheckBox;
    private jp.riken.brain.ni.samuraigraph.base.SGCheckBox mHighlightDataCheckBox;
    private javax.swing.JScrollPane mScrollPane;
    private javax.swing.JTable mTable;
    private jp.riken.brain.ni.samuraigraph.base.SGTextField mTextField;
    private javax.swing.JPanel mTopInnerPanel;
    private javax.swing.JPanel mTopPanel;
    // End of variables declaration//GEN-END:variables

	public static final String TITLE_PREFIX = "Data Viewer: ";
	
    public static final String DATA_EDITED = "Data edited";

    public static final String CLOSE_BUTTON_TEXT = "Close";

	// The default value for reducing.
	private static boolean mDefaultReduce = true;
	
	// The default value for highlighting.
	private static boolean mDefaultHighlighting = false;

    private SGData mData = null;
    
    private String mDataName = null;
    
    private int mPrevColumn = -1;
    
    private int mPrevRow = -1;
    
    private void initProperty() {
        // add event listeners
        this.mCloseButton.addActionListener(this);
        this.mColumnTypeComboBox.addItemListener(new ItemListener() {
			@Override
			public void itemStateChanged(ItemEvent e) {
				updateTable();
			}
        });

        // set up the selection mode
        this.mTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
		this.mTable.setCellSelectionEnabled(true);
		final JTableHeader header = this.mTable.getTableHeader();
		header.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isLeftMouseButton(e)) {
    				final JScrollBar scrollBar = mScrollPane.getVerticalScrollBar();
    				final int value = scrollBar.getValue();
    				final int mod = e.getModifiersEx();
    				final boolean isCtrlPressed = ((mod & InputEvent.CTRL_DOWN_MASK) != 0);
    				final boolean isShiftPressed = ((mod & InputEvent.SHIFT_DOWN_MASK) != 0);
    				final int col = header.columnAtPoint(e.getPoint());
    				if (col == -1 || col == 0) {
    					return;
    				}
    				final int rowMax = mTable.getRowCount() - 1;
    				boolean singleColumn = false;
    				if (isShiftPressed) {
    					if (mPrevColumn != -1) {
    						mTable.changeSelection(0, mPrevColumn, false, false);
    						mTable.changeSelection(rowMax, col, false, true);
    					} else {
    						singleColumn = true;
    					}
    				} else if (isCtrlPressed) {
    					if (mPrevColumn != -1) {
    						mTable.addColumnSelectionInterval(col, col);
    						mPrevColumn = col;
    					} else {
    						singleColumn = true;
    					}
    				} else {
    					singleColumn = true;
    				}
    				if (singleColumn) {
    					mTable.changeSelection(0, col, false, false);
    					mTable.changeSelection(rowMax, col, false, true);
    					mPrevColumn = col;
    				}
    				SwingUtilities.invokeLater(new Runnable() {
    					public void run() {
    						scrollBar.setValue(value);
    					}
    				});
                }
			}
		});
		header.addMouseMotionListener(new MouseAdapter() {
			@Override
			public void mouseDragged(MouseEvent e) {
				if (mPrevColumn != -1) {
					final int col = header.columnAtPoint(e.getPoint());
    				if (col == -1) {
    					return;
    				}
					mTable.setColumnSelectionInterval(mPrevColumn, col);
				}
			}
		});
		this.mTable.addMouseListener(new MouseAdapter() {
			@Override
			public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isLeftMouseButton(e)) {
    				final int col = mTable.columnAtPoint(e.getPoint());
    				if (col == -1) {
    					return;
    				}
    				if (col == 0) {
        				final JScrollBar scrollBar = mScrollPane.getHorizontalScrollBar();
        				final int value = scrollBar.getValue();
        				final int mod = e.getModifiersEx();
        				final boolean isCtrlPressed = ((mod & InputEvent.CTRL_DOWN_MASK) != 0);
        				final boolean isShiftPressed = ((mod & InputEvent.SHIFT_DOWN_MASK) != 0);
        				final int row = mTable.rowAtPoint(e.getPoint());
        				final int colMin = 1;
        				final int colMax = mTable.getColumnCount() - 1;
        				boolean singleRow = false;
        				if (isShiftPressed) {
        					if (mPrevRow != -1) {
        						mTable.changeSelection(mPrevRow, colMin, false, false);
        						mTable.changeSelection(row, colMax, false, true);
        					} else {
        						singleRow = true;
        					}
        				} else if (isCtrlPressed) {
        					if (mPrevRow != -1) {
        						mTable.addRowSelectionInterval(row, row);
        						mPrevRow = row;
        					} else {
        						singleRow = true;
        					}
        				} else {
        					singleRow = true;
        				}
        				if (singleRow) {
        					mTable.changeSelection(row, colMin, false, false);
        					mTable.changeSelection(row, colMax, false, true);
        					mPrevRow = row;
        				}
        				SwingUtilities.invokeLater(new Runnable() {
        					public void run() {
        						scrollBar.setValue(value);
        					}
        				});
        				
        				return;
    				}
                }
                
                // update the text field
				updateComponents();
			}
			
			@Override
			public void mouseClicked(MouseEvent e) {
                if (SwingUtilities.isRightMouseButton(e)) {
    				final int col = mTable.columnAtPoint(e.getPoint());
    				if (col == -1) {
    					return;
    				}
    				if (col != 0) {
                    	mPopupMenu.show(mTable, e.getX(), e.getY());
    				}
                }
			}
		});
		this.mTable.addMouseMotionListener(new MouseAdapter() {
			@Override
			public void mouseDragged(MouseEvent e) {
				final int col = mTable.columnAtPoint(e.getPoint());
				if (col == -1) {
					return;
				}
				if (col == 0) {
					if (mPrevRow != -1) {
						final int row = mTable.rowAtPoint(e.getPoint());
						if (row != -1) {
							mTable.setRowSelectionInterval(mPrevRow, row);
						}
					}
				}
				
                // update the text field
				updateComponents();
			}
		});
		this.mScrollPane.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseClicked(MouseEvent e) {
				clearSelection();
			}
		});
		this.mClearSelectionButton.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				clearSelection();
			}
		});
		this.mHideEmptyCellsCheckBox.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				mDefaultReduce = mHideEmptyCellsCheckBox.isSelected();
				clearSelection();
				updateTable();
			}
		});
		this.mHighlightDataCheckBox.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				mDefaultHighlighting = mHighlightDataCheckBox.isSelected();
			}
		});

        this.setResizable(true);
        this.mTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
        this.mTable.getTableHeader().setReorderingAllowed(false);
        this.mClearSelectionButton.setEnabled(false);
        this.mHideEmptyCellsCheckBox.setSelected(mDefaultReduce);
        this.mHighlightDataCheckBox.setSelected(mDefaultHighlighting);
        
        // set up the scroll bar properties
        JScrollBar vertBar = this.mScrollPane.getVerticalScrollBar();
        vertBar.setUnitIncrement(SGIConstants.SCROLL_BAR_UNIT_INCREMENT);
        vertBar.setBlockIncrement(SGIConstants.SCROLL_BAR_BLOCK_INCREMENT);

        // create the popup menu
        this.mPopupMenu = this.createPopupMenu();
    }
    
    private void clearSelection() {
		this.mTable.clearSelection();
		TableCellEditor editor = this.mTable.getCellEditor();
		if (editor != null) {
			editor.stopCellEditing();
		}
		this.mClearSelectionButton.setEnabled(false);
		this.mTextField.setText("");
    }
    
    private JPopupMenu mPopupMenu = null;

    public static String MENUCMD_DRAW_GRAPH = "Draw Graph";

    public static String MENUCMD_SEND_TO_PLUG_IN = "Send to Plug-in";
    
    protected JPopupMenu createPopupMenu() {
        JPopupMenu p = new JPopupMenu();
        p.setBounds(0, 0, 100, 100);
        SGUtility.addItem(p, this, MENUCMD_DRAW_GRAPH);
        
    	// plug-in
        JMenu pluginMenu = SGUtility.addMenu(p, this, MENUCMD_SEND_TO_PLUG_IN);
    	ActionListener l = new ActionListener() {
    		public void actionPerformed(ActionEvent e) {
    			String command = e.getActionCommand();
    			notifyToListener(command);
    		}
    	};
        if (mDataPluginList != null && mDataPluginList.size() != 0) {
        	for (SGIPlugin lib : mDataPluginList) {
        		String text = SGUtility.createPluginItemString(lib);
        		if (text == null) {
        			continue;
        		}
        		String cmd = lib.getCommand();
        		SGUtility.addItem(pluginMenu, l, text, cmd, true);
        	}
        } else {
        	String cmd = SGIPluginManager.NO_PLUGIN;
    		SGUtility.addItem(pluginMenu, l, cmd, cmd, false);
        }

        return p;
    }

    private void updateComponents() {
    	// text field
		int[] cols = this.getSelectedTableColumns();
		int[] rows = this.getSelectedTableRows();
		String text = "";
		if (cols.length == 1 && rows.length == 1) {
			Object value = this.getValueAt(rows[0], cols[0]);
			if (value != null) {
				text = value.toString();
			}
		}
		this.mTextField.setText(text);
		
		// clear button
		final boolean clearButtonEnabled = (cols.length > 0 && rows.length > 0);
		this.mClearSelectionButton.setEnabled(clearButtonEnabled);
    }
    
	@Override
    public void actionPerformed(ActionEvent e) {
    	super.actionPerformed(e);
    	Object source = e.getSource();
    	if (source.equals(this.mCloseButton)) {
    		this.close();
    	}
		String command = e.getActionCommand();
		this.notifyToListener(command);
    }
    
	@Override
	protected void onEscKeyTyped() {
		this.close();
	}

	/**
	 * Closes this dialog.
	 * 
	 */
    public void close() {
    	this.setVisible(false);
    }

    /**
     * Returns the data.
     * 
     * @return the data
     */
    public SGData getData() {
    	return this.mData;
    }
    
    /**
     * Returns the name of data.
     * 
     * @return the name of data
     */
    public String getDataName() {
    	return this.mDataName;
    }

    /**
     * Sets data to this dialog.
     * 
     * @param data
     *          the data
     * @param name
     *          name of the data
     */
    public void setData(final SGData data, final String name) {
    	if (data == null || name == null) {
    		throw new IllegalArgumentException("data == null || name == null");
    	}
    	this.mData = data;
    	this.mDataName = name;

    	// set title
    	StringBuffer sb = new StringBuffer();
    	sb.append(TITLE_PREFIX);
    	sb.append(SGUtility.removeEscapeChar(name));
    	this.setTitle(sb.toString());
    	
    	// updates the combo box for the column types
    	this.mColumnTypeComboBox.removeAllItems();
    	String[] columnTypes = data.getDataViewerColumnTypes();
    	for (String columnType : columnTypes) {
    		this.mColumnTypeComboBox.addItem(columnType);
    	}
    	this.mColumnTypeComboBox.setSelectedItem(
    			data.getPreferredDataViewColumnType());
    	
    	// updates the table
    	this.updateTable();
    	
    	this.pack();
    }

    // Updates the table.
    private void updateTable() {
		final String columnType = this.getColumnType();
		DefaultTableModel model = new DataViewerTableModel();
    	
		// add the row number column
    	final String numberRowId = "";
		model.addColumn(numberRowId);

    	// add rows and columns
		final boolean reduced = this.isReduced();
		final boolean all = (!reduced  || !this.mData.isStrideAvailable());
		final int colNum = this.mData.getDataViewerColumnNumber(columnType, all);
		final int rowNum = this.mData.getDataViewerRowNumber(columnType, all);
		String[] colNames = new String[colNum];
		if (all) {
	    	for (int ii = 0; ii < colNum; ii++) {
	    		colNames[ii] = Integer.toString(ii);
	    	}
		} else {
			SGIntegerSeriesSet colStride = this.mData.getDataViewerColStride(columnType);
			int[] indices = colStride.getNumbers();
	    	for (int ii = 0; ii < colNum; ii++) {
	    		colNames[ii] = Integer.toString(indices[ii]);
	    	}
		}
		String[] rowNames = new String[rowNum];
		if (all) {
	    	for (int ii = 0; ii < rowNum; ii++) {
	    		rowNames[ii] = Integer.toString(ii);
	    	}
		} else {
			SGIntegerSeriesSet rowStride = this.mData.getDataViewerRowStride(columnType);
			int[] indices = rowStride.getNumbers();
	    	for (int ii = 0; ii < rowNum; ii++) {
	    		rowNames[ii] = Integer.toString(indices[ii]);
	    	}
		}
    	for (int ii = 0; ii < colNum; ii++) {
    		model.addColumn(colNames[ii]);
    	}
    	for (int ii = 0; ii < rowNum; ii++) {
    		Object[] row = new Object[colNum + 1];
			model.addRow(row);
    	}
		this.mTable.setModel(model);
		
        JTextField textField = new JTextField();
        textField.setBorder(BorderFactory.createEmptyBorder());
		for (int ii = 0; ii < colNum; ii++) {
			TableColumn col = this.mTable.getColumn(colNames[ii]);
			col.setCellRenderer(new DataValueColumnCellRenderer());
			col.setCellEditor(new DataValueColumnCellEditor(textField));
		}
		
		// set up the row number column
        TableColumn rowNumberColumn = this.mTable.getColumn(numberRowId);
        rowNumberColumn.setPreferredWidth(40);
    	rowNumberColumn.setResizable(false);
    	rowNumberColumn.setCellRenderer(new RowIndexColumnCellRenderer(rowNames));

    	// set preferred column width
        for (int ii = 0; ii < colNum; ii++) {
            TableColumn cl = this.mTable.getColumn(colNames[ii]);
            cl.setPreferredWidth(80);
        }
        
        this.mClearSelectionButton.setEnabled(false);

        // set enabled reduce check box
    	final boolean reduceAvailable;
    	if (this.mData.isStrideAvailable()) {
    		SGIntegerSeriesSet colStride = this.mData.getDataViewerColStride(columnType);
    		SGIntegerSeriesSet rowStride = this.mData.getDataViewerRowStride(columnType);
    		reduceAvailable = !(colStride.isComplete() && rowStride.isComplete());
    	} else {
    		reduceAvailable = false;
    	}
    	this.mHideEmptyCellsCheckBox.setEnabled(reduceAvailable);
    }
    
    public String getColumnType() {
   		Object item = this.mColumnTypeComboBox.getSelectedItem();
		final String columnType = item.toString();
		return columnType;
    }
    
    private SGTwoDimensionalArrayIndex getIndex(final String columnType, final int tableRowIndex, 
    		final int tableColumnIndex) {
		final int row = tableRowIndex;
		final int col = tableColumnIndex - 1;	// minus 1 for row-header
    	final int rIndex, cIndex;
    	if (!this.mData.isStrideAvailable()) {
    		rIndex = row;
    		cIndex = col;
    	} else {
        	SGIntegerSeriesSet rowStride = this.mData.getDataViewerRowStride(columnType);
        	SGIntegerSeriesSet colStride = this.mData.getDataViewerColStride(columnType);
    		if (this.isReduced()) {
            	int[] rowIndices = rowStride.getNumbers();
    			rIndex = rowIndices[row];
            	int[] colIndices = colStride.getNumbers();
            	cIndex = colIndices[col];
    		} else {
            	if (rowStride.search(row) < 0) {
            		return null;
            	}
            	rIndex = row;
            	if (colStride.search(col) < 0) {
            		return null;
            	}
            	cIndex = col;
    		}
    	}
    	SGTwoDimensionalArrayIndex ret = new SGTwoDimensionalArrayIndex(cIndex, rIndex);
    	return ret;
    }
    
    public Object getValueAt(final int tableRowIndex, final int tableColumnIndex) {
		final String columnType = this.getColumnType();
		SGTwoDimensionalArrayIndex indices = this.getIndex(columnType, tableRowIndex, tableColumnIndex);
		if (indices == null) {
			return null;
		}
		return this.mData.getDataViewerValue(columnType, indices.getRow(), indices.getColumn());
    }
    
    public void setValueAt(final int tableRowIndex, final int tableColumnIndex, Object value) {
    	if (tableRowIndex == -1 || tableColumnIndex == -1) {
    		return;
    	}
    	if (value == null) {
    		return;
    	}
		final String columnType = this.getColumnType();
		SGTwoDimensionalArrayIndex indices = this.getIndex(columnType, tableRowIndex, tableColumnIndex);
		if (indices != null) {
			this.mData.setDataViewerValue(columnType, indices.getRow(), indices.getColumn(), value);
		}
    }

    private int[] getSelectedTableColumns() {
    	int[] cols = this.mTable.getSelectedColumns();
    	return cols;
    }

    private int[] getSelectedTableRows() {
    	int[] rows = this.mTable.getSelectedRows();
    	return rows;
    }
    
    public List<SGXYSimpleDoubleValueIndexBlock> getSelectedValues() {
    	List<SGXYSimpleDoubleValueIndexBlock> ret = new ArrayList<SGXYSimpleDoubleValueIndexBlock>();
    	List<SGSimpleIndexBlock> blockList = this.getSelectedCells(true);
    	for (SGSimpleIndexBlock block : blockList) {
    		ret.add((SGXYSimpleDoubleValueIndexBlock) block);
    	}
    	return ret;
    }

    public List<SGXYSimpleIndexBlock> getSelectedCells() {
    	List<SGXYSimpleIndexBlock> ret = new ArrayList<SGXYSimpleIndexBlock>();
    	List<SGSimpleIndexBlock> blockList = this.getSelectedCells(false);
    	for (SGSimpleIndexBlock block : blockList) {
    		ret.add((SGXYSimpleIndexBlock) block);
    	}
    	return ret;
    }

    private List<SGSimpleIndexBlock> getSelectedCells(final boolean withValues) {
    	List<SGSimpleIndexBlock> blockList = new ArrayList<SGSimpleIndexBlock>();
		int[] tableCols = this.getSelectedTableColumns();
		tableCols = SGUtility.remove(tableCols, 0);	// remove a column for row-header
		int[] tableRows = this.getSelectedTableRows();
		SGIntegerSeries[] tableColSeriesArray = createSeriesArray(tableCols);
		SGIntegerSeries[] tableRowSeriesArray = createSeriesArray(tableRows);
		for (SGIntegerSeries tableColSeries : tableColSeriesArray) {
			for (SGIntegerSeries tableRowSeries : tableRowSeriesArray) {
				int[] tableColIndices = tableColSeries.getNumbers();
				int[] tableRowIndices = tableRowSeries.getNumbers();
				final int tableColNum = tableColIndices.length;
				final int tableRowNum = tableRowIndices.length;
				double[] values = null;
				if (withValues) {
					List<Double> valueList = new ArrayList<Double>();
					for (int cc = 0; cc < tableColNum; cc++) {
						for (int rr = 0; rr < tableRowNum; rr++) {
							final int tableRowIndex = tableRowIndices[rr];
							final int tableColIndex = tableColIndices[cc];
							Object obj = this.getValueAt(tableRowIndex, tableColIndex);
							if (obj == null) {
								continue;
							}
							if (obj instanceof Double) {
								valueList.add((Double) obj);
							}
						}
					}
					values = new double[valueList.size()];
					for (int ii = 0; ii < values.length; ii++) {
						values[ii] = valueList.get(ii);
					}
				}

				// minus 1 for row-header
				for (int ii = 0; ii < tableColIndices.length; ii++) {
					tableColIndices[ii]--;
				}

				SGIntegerSeries dataColSeries;
				SGIntegerSeries dataRowSeries;
				if (!this.mData.isStrideAvailable()) {
					List<SGIntegerSeries> dataColSeriesList = SGIntegerSeries.createList(tableColIndices);
					dataColSeries = dataColSeriesList.get(0);
					dataRowSeries = tableRowSeries;
				} else {
					String columnType = this.getColumnType();
		        	SGIntegerSeriesSet rowStride = this.mData.getDataViewerRowStride(columnType);
		        	SGIntegerSeriesSet colStride = this.mData.getDataViewerColStride(columnType);
					if (this.isReduced()) {
						int[] dataRowIndices = rowStride.getNumbers();
						int[] rowIndicesNew = new int[tableRowIndices.length];
						for (int ii = 0; ii < tableRowIndices.length; ii++) {
							rowIndicesNew[ii] = dataRowIndices[tableRowIndices[ii]];
						}
						List<SGIntegerSeries> dataRowSeriesList = SGIntegerSeries.createList(rowIndicesNew);
						dataRowSeries = dataRowSeriesList.get(0);
						
						int[] dataColIndices = colStride.getNumbers();
						int[] colIndicesNew = new int[tableColIndices.length];
						for (int ii = 0; ii < tableColIndices.length; ii++) {
							colIndicesNew[ii] = dataColIndices[tableColIndices[ii]];
						}
						List<SGIntegerSeries> dataColSeriesList = SGIntegerSeries.createList(colIndicesNew);
						dataColSeries = dataColSeriesList.get(0);
						
					} else {
						List<Integer> rowList = rowStride.getExisting(tableRowIndices);
						if (rowList.size() == 0) {
							continue;
						}
						List<Integer> colList = colStride.getExisting(tableColIndices);
						if (colList.size() == 0) {
							continue;
						}
						int[] rowIndicesNew = new int[rowList.size()];
						for (int ii = 0; ii < rowList.size(); ii++) {
							rowIndicesNew[ii] = rowList.get(ii);
						}
						int[] colIndicesNew = new int[colList.size()];
						for (int ii = 0; ii < colList.size(); ii++) {
							colIndicesNew[ii] = colList.get(ii);
						}
						List<SGIntegerSeries> dataColSeriesList = SGIntegerSeries.createList(colIndicesNew);
						dataColSeries = dataColSeriesList.get(0);
						List<SGIntegerSeries> dataRowSeriesList = SGIntegerSeries.createList(rowIndicesNew);
						dataRowSeries = dataRowSeriesList.get(0);
					}
				}
				
				SGSimpleIndexBlock block = null;
				if (withValues) {
					block = new SGXYSimpleDoubleValueIndexBlock(values, dataColSeries, dataRowSeries);
				} else {
					block = new SGXYSimpleIndexBlock(dataColSeries, dataRowSeries);
				}
				blockList.add(block);
			}
		}
    	return blockList;
    }
    
    private static SGIntegerSeries[] createSeriesArray(int[] indices) {
    	Arrays.sort(indices);
    	List<SGIntegerSeries> seriesList = new ArrayList<SGIntegerSeries>();
    	int prev = -1;
    	int start = -1;
    	int cur = -1;
    	for (int ii = 0; ii < indices.length; ii++) {
    		cur = indices[ii];
    		if (prev != -1) {
    			if (cur != prev + 1) {
    				SGIntegerSeries series = new SGIntegerSeries(start, prev, 1);
    				seriesList.add(series);
    				start = cur;
    			}
    		} else {
    			start = cur;
    		}
			prev = cur;
    	}
    	if (start != -1 && cur != -1) {
			SGIntegerSeries series = new SGIntegerSeries(start, cur, 1);
			seriesList.add(series);
    	}
    	return seriesList.toArray(new SGIntegerSeries[seriesList.size()]);
    }

    class DataViewerTable extends JTable {
    	
		private static final long serialVersionUID = 4975977790170441000L;

		public DataViewerTable() {
    		super();
    	}
    	
    	@Override
    	public void changeSelection(final int rowIndex, final int columnIndex,
    			final boolean toggle, final boolean extend) {
    		if (columnIndex != 0) {
    			super.changeSelection(rowIndex, columnIndex, toggle, extend);
    		}
    	}
    	
    	@Override
    	public boolean isCellEditable(final int row, final int column) {
    		if (column == 0) {
    			return false;
    		}
    		Object value = SGDataViewerDialog.this.getValueAt(row, column);
    		return (value != null);
    	}
    	
    	@Override
    	public void editingStopped(ChangeEvent e) {
    		super.editingStopped(e);
    		Object source = e.getSource();
    		DataValueColumnCellEditor editor = (DataValueColumnCellEditor) source;
    		SGDataViewerDialog.this.setValueAt(editor.mLastEditedRow, 
    				editor.mLastEditedColumn, editor.getCellEditorValue());
    		notifyToListener(DATA_EDITED);
    	}
    }
    
    /**
     * The table model.
     *
     */
    class DataViewerTableModel extends DefaultTableModel {
    	
		private static final long serialVersionUID = -8926789404979788769L;

		public DataViewerTableModel() {
            super();
        }

		@Override
        public boolean isCellEditable(int rowIndex, int columnIndex) {
        	return false;
        }
    }

    /**
     * Cell renderer for the column of row index.
     *
     */
    class RowIndexColumnCellRenderer extends DefaultTableCellRenderer {

		private static final long serialVersionUID = -193719434449049386L;

		private String[] mRowNames = null;
		
		public RowIndexColumnCellRenderer(String[] rowNames) {
            super();
        	JTableHeader header = mTable.getTableHeader();
        	this.setBackground(header.getBackground());
        	this.setForeground(header.getForeground());
        	this.mRowNames = rowNames;
        }

        @Override
        public Component getTableCellRendererComponent(JTable table,
                Object value, boolean isSelected, boolean hasFocus, int row,
                int column) {
        	this.setText(this.mRowNames[row]);
        	return this;
        }
    }
    
    /**
     * Cell renderer for the column of data values.
     *
     */
    class DataValueColumnCellRenderer extends DefaultTableCellRenderer {
    	
		private static final long serialVersionUID = -193719434449049386L;

		public DataValueColumnCellRenderer() {
    		super();
    	}
    	
        @Override
        public Component getTableCellRendererComponent(JTable table,
                Object value, boolean isSelected, boolean hasFocus, int row,
                int column) {
            Component com = super.getTableCellRendererComponent(table, value, isSelected, 
            		hasFocus, row, column);
            DefaultTableCellRenderer renderer = (DefaultTableCellRenderer) com;
    		Object obj = getValueAt(row, column);
    		if (obj != null) {
        		String text = obj.toString();
                renderer.setText(text);
    		}
        	return com;
        }
    }

    /**
     * Cell renderer for the column of data values.
     *
     */
    class DataValueColumnCellEditor extends DefaultCellEditor {
    	
		private static final long serialVersionUID = -1937410713508285565L;
		
		int mLastEditedRow = -1;
		
		int mLastEditedColumn = -1;

		public DataValueColumnCellEditor(JTextField textField) {
    		super(textField);
    	}
    	
		@Override
		public Component getTableCellEditorComponent(final JTable table, final Object value, 
				final boolean isSelected, final int row, final int column) {
			Component com = super.getTableCellEditorComponent(table, value, 
					isSelected, row, column);
			final JTextField tf = (JTextField) com;
			Object v = SGDataViewerDialog.this.getValueAt(row, column);
			if (v != null) {
				final String str = v.toString();
				tf.setText(str);
				this.mLastEditedRow = row;
				this.mLastEditedColumn = column;
			}
			return com;
		}
    }

    // The list of data plug-in.
    private static List<SGIPlugin> mDataPluginList = null;

    /**
     * Sets the list of data plug-in.
     * 
     * @param pluginList
     *           the list of data plug-in
     */
    public static void setDataPlugins(List<SGIPlugin> pluginList) {
    	mDataPluginList = new ArrayList<SGIPlugin>(pluginList);
    }

    public void addTableSelectionListener(ListSelectionListener x) {
    	this.mTable.getSelectionModel().addListSelectionListener(x);
    }
    
    public void addTableMouseListener(MouseListener l) {
    	this.mTable.addMouseListener(l);
    	this.mTable.getTableHeader().addMouseListener(l);
    }
    
    public void addTableMouseMotionListener(MouseMotionListener l) {
    	this.mTable.addMouseMotionListener(l);
    	this.mTable.getTableHeader().addMouseMotionListener(l);
    }
    
    public void addHilightChangedActionListener(ActionListener l) {
    	this.mHighlightDataCheckBox.addActionListener(l);
    }
    
    public boolean isReduced() {
    	return this.mHideEmptyCellsCheckBox.isSelected();
    }
    
    public boolean isHilighting() {
    	return this.mHighlightDataCheckBox.isSelected();
    }
    
    public void refresh() {
    	this.updateTable();
    	this.updateComponents();
    	this.repaint();
    }
    
    public void setSelectedIndices(List<SGTwoDimensionalArrayIndex> indexList) {
    	if (indexList == null) {
    		return;
    	}
    	this.mTable.clearSelection();
    	Rectangle rectAll = null;
    	final String columnType = this.getColumnType();
    	for (SGTwoDimensionalArrayIndex cell : indexList) {
        	final boolean bStride = this.mData.isStrideAvailable() 
        			&& this.mHideEmptyCellsCheckBox.isSelected(); 
        	SGTwoDimensionalArrayIndex cellNew = this.mData.getDataViewerCell(
        			cell, columnType, bStride);
        	final int tableRow = cellNew.getRow();
        	final int tableCol = cellNew.getColumn() + 1;		// add 1 for column header
    		this.mTable.addRowSelectionInterval(tableRow, tableRow);
    		this.mTable.addColumnSelectionInterval(tableCol, tableCol);
            Rectangle cellRect = this.mTable.getCellRect(tableRow, tableCol, false);
            if (rectAll == null) {
            	rectAll = cellRect;
            } else {
            	rectAll = rectAll.union(cellRect);
            }
    	}
        if (rectAll != null) {
            this.mTable.scrollRectToVisible(rectAll);
            this.mClearSelectionButton.setEnabled(true);
        }
    }
}
